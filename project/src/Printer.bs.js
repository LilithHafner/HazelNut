// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Pervasives = require("bs-platform/lib/js/pervasives.js");

function string_of_one_constraint_(c) {
  if (!c) {
    return "-";
  }
  var match = c[0];
  return string_of_env(match[0]) + (": " + (String(match[1][0]) + ("->String of example not implemented; " + string_of_one_constraint_(c[1]))));
}

function string_of_type_(t) {
  if (typeof t === "number") {
    switch (t) {
      case /* Int_t */0 :
          return "Int";
      case /* Bool_t */1 :
          return "Bool";
      case /* Unit_t */2 :
          return "Unit";
      case /* Any_t */3 :
          return "Any";
      case /* Fail_t */4 :
          return "Fail";
      
    }
  } else {
    switch (t.tag | 0) {
      case /* Cons_t */0 :
          return "Cons(" + (string_of_type_(t[0]) + ("," + (string_of_type_(t[1]) + ")")));
      case /* Function_t */1 :
          return "(" + (string_of_type_(t[0]) + ("->" + (string_of_type_(t[1]) + ")")));
      case /* Pair_t */2 :
          return "(" + (string_of_type_(t[0]) + (", " + (string_of_type_(t[1]) + ")")));
      
    }
  }
}

function string_of_res(r) {
  if (typeof r === "number") {
    if (r === /* Rnil */0) {
      return "Nil";
    } else {
      return "()";
    }
  }
  switch (r.tag | 0) {
    case /* Rint */0 :
        return String(r[0]);
    case /* Rfloat */1 :
        return r[0].toString();
    case /* Rbool */2 :
        return Pervasives.string_of_bool(r[0]);
    case /* Rcons */3 :
        return string_of_res(r[0]) + ("::" + string_of_res(r[1]));
    case /* Rfunc */4 :
        return "[" + (string_of_env(r[2]) + ("]\\" + (String(r[0]) + ("." + string_of_exp(r[1])))));
    case /* Rapp */5 :
        return string_of_res(r[0]) + (" " + string_of_res(r[1]));
    case /* Rhole */6 :
        return "[" + (string_of_env(r[1]) + ("]??_" + String(r[0])));
    case /* Rpair */7 :
        return "(" + (string_of_res(r[0]) + (", " + (string_of_res(r[1]) + ")")));
    case /* Rfst */8 :
        return "fst(" + (string_of_res(r[0]) + ")");
    case /* Rsnd */9 :
        return "snd(" + (string_of_res(r[0]) + ")");
    
  }
}

function string_of_env(e) {
  if (!e) {
    return "-";
  }
  var match = e[0];
  return String(match[0]) + ("->" + (string_of_res(match[1]) + ("; " + string_of_env(e[1]))));
}

function string_of_exp(e) {
  if (typeof e === "number") {
    if (e === /* Nil */0) {
      return "Nil";
    } else {
      return "()";
    }
  }
  switch (e.tag | 0) {
    case /* Float */1 :
        return e[0].toString();
    case /* Bool */2 :
        return Pervasives.string_of_bool(e[0]);
    case /* Cons */3 :
        return string_of_exp(e[0]) + ("::" + string_of_exp(e[1]));
    case /* Function */5 :
        return "\\" + (String(e[0]) + ("." + string_of_exp(e[1])));
    case /* Application */6 :
        return string_of_exp(e[0]) + (" " + string_of_exp(e[1]));
    case /* Hole */7 :
        return "??_" + String(e[0]);
    case /* Int */0 :
    case /* Variable */4 :
    case /* Var */8 :
        return String(e[0]);
    case /* Pair */9 :
        return "(" + (string_of_exp(e[0]) + (", " + (string_of_exp(e[1]) + ")")));
    case /* Fst */10 :
        return "fst(" + (string_of_exp(e[0]) + ")");
    case /* Snd */11 :
        return "snd(" + (string_of_exp(e[0]) + ")");
    
  }
}

function string_of_identifier(prim) {
  return String(prim);
}

function string_of_hole_identifier(prim) {
  return String(prim);
}

function string_of_example(param) {
  return "String of example not implemented";
}

function string_of_constraint_(c) {
  if (c !== undefined) {
    return string_of_one_constraint_(c);
  } else {
    return "None";
  }
}

function string_of_debug_construct(c) {
  switch (c.tag | 0) {
    case /* Exp */0 :
        return string_of_exp(c[0]);
    case /* Environment */1 :
        return string_of_env(c[0]);
    case /* Res */2 :
        return string_of_res(c[0]);
    case /* Type_ */3 :
        return string_of_type_(c[0]);
    case /* Example */4 :
        return "String of example not implemented";
    case /* Constraint_ */5 :
        return string_of_constraint_(c[0]);
    
  }
}

exports.string_of_debug_construct = string_of_debug_construct;
exports.string_of_exp = string_of_exp;
exports.string_of_res = string_of_res;
exports.string_of_env = string_of_env;
exports.string_of_identifier = string_of_identifier;
exports.string_of_hole_identifier = string_of_hole_identifier;
exports.string_of_type_ = string_of_type_;
exports.string_of_example = string_of_example;
exports.string_of_one_constraint_ = string_of_one_constraint_;
exports.string_of_constraint_ = string_of_constraint_;
/* No side effect */
