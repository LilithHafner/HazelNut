// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Tools$MyNewProject = require("./Tools.bs.js");
var Types$MyNewProject = require("./Types.bs.js");
var Typing$MyNewProject = require("./Typing.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var memo = Caml_array.caml_make_vect(10, /* [] */0);

function resetMemo(param) {
  return $$Array.mapi((function (i, x) {
                return Caml_array.caml_array_set(memo, i, /* [] */0);
              }), memo);
}

function partition_h(n, m, i) {
  if (m === i) {
    return /* [] */0;
  } else {
    return /* :: */[
            /* tuple */[
              n,
              m
            ],
            partition_h(n - 1 | 0, m + 1 | 0, i)
          ];
  }
}

function partition(n) {
  return partition_h(n - 1 | 0, 1, n);
}

function guessFst(delta, gamma, typ, i) {
  var candidates = List.filter((function (e) {
            var t = Typing$MyNewProject.getType(delta, gamma, e);
            if (typeof t === "number" || t.tag !== /* Pair_t */2) {
              return false;
            } else {
              return true;
            }
          }))(Caml_array.caml_array_get(memo, i - 2 | 0));
  var ret = List.map((function (e) {
          return /* Fst */Block.__(9, [e]);
        }), candidates);
  List.map((function (e) {
          return e;
        }), ret);
  return ret;
}

function guessSnd(delta, gamma, typ, i) {
  var candidates = List.filter((function (e) {
            var match = Typing$MyNewProject.getType(delta, gamma, e);
            if (typeof match === "number" || match.tag !== /* Pair_t */2) {
              return false;
            } else {
              return true;
            }
          }))(Caml_array.caml_array_get(memo, i - 2 | 0));
  return List.map((function (e) {
                return /* Snd */Block.__(10, [e]);
              }), candidates);
}

function guessPairs(delta, gamma, t1, t2, i, j) {
  return List.concat(List.map((function (e1) {
                    return List.map((function (e2) {
                                  return /* Pair */Block.__(8, [
                                            e1,
                                            e2
                                          ]);
                                }), List.filter((function (e2) {
                                        return Caml_obj.caml_equal(Typing$MyNewProject.getType(delta, gamma, e2), t2);
                                      }))(Caml_array.caml_array_get(memo, j - 1 | 0)));
                  }), List.filter((function (e) {
                          return Caml_obj.caml_equal(Typing$MyNewProject.getType(delta, gamma, e), t1);
                        }))(Caml_array.caml_array_get(memo, i - 1 | 0))));
}

function guessCtors(delta, gamma, typ, i) {
  if (typeof typ === "number") {
    return /* [] */0;
  }
  if (typ.tag !== /* D */3) {
    return /* [] */0;
  }
  var adt = typ[0];
  var constructors = Tools$MyNewProject.lookup(adt, Types$MyNewProject.sigma);
  return List.concat(List.map((function (param) {
                    var t = param[1];
                    var c = param[0];
                    if (typeof t !== "number" && t.tag === /* Pair_t */2) {
                      var t2 = t[1];
                      var t1 = t[0];
                      var pairs = partition(i);
                      return List.map((function (e) {
                                    return /* Ctor */Block.__(11, [
                                              c,
                                              adt,
                                              e
                                            ]);
                                  }), List.concat(List.map((function (param) {
                                            return guessPairs(delta, gamma, t1, t2, param[0], param[1]);
                                          }), pairs)));
                    }
                    return List.map((function (e) {
                                  return /* Ctor */Block.__(11, [
                                            c,
                                            adt,
                                            e
                                          ]);
                                }), List.filter((function (e) {
                                        return Caml_obj.caml_equal(Typing$MyNewProject.getType(delta, gamma, e), t);
                                      }))(Caml_array.caml_array_get(memo, i - 2 | 0)));
                  }), constructors));
}

function guessApp(delta, gamma, typ, i, j) {
  var funcs = List.filter((function (e) {
            var match = Typing$MyNewProject.getType(delta, gamma, e);
            if (typeof match === "number" || match.tag !== /* Function_t */1) {
              return false;
            } else {
              return true;
            }
          }))(Caml_array.caml_array_get(memo, i - 1 | 0));
  return List.concat(List.map((function (e) {
                    var candidates = List.filter((function (x) {
                              var match = Typing$MyNewProject.getType(delta, gamma, e);
                              if (typeof match === "number") {
                                throw [
                                      Caml_builtin_exceptions.match_failure,
                                      /* tuple */[
                                        "Guesser.re",
                                        108,
                                        24
                                      ]
                                    ];
                              }
                              if (match.tag === /* Function_t */1) {
                                var t1 = match[0];
                                var t = Typing$MyNewProject.getType(delta, gamma, x);
                                if (typeof e === "number") {
                                  return Caml_obj.caml_equal(t, t1);
                                }
                                switch (e.tag | 0) {
                                  case /* Function */4 :
                                  case /* Var */7 :
                                      break;
                                  default:
                                    return Caml_obj.caml_equal(t, t1);
                                }
                                var match$1 = Tools$MyNewProject.lookup(e[0], gamma);
                                if (match$1[1] !== /* AnnFunc */3) {
                                  return Caml_obj.caml_equal(t, t1);
                                }
                                if (typeof x === "number") {
                                  return false;
                                }
                                if (x.tag !== /* Var */7) {
                                  return false;
                                }
                                var match$2 = Tools$MyNewProject.lookup(x[0], gamma);
                                if (match$2[1] === /* AnnRec */2) {
                                  return Caml_obj.caml_equal(t, t1);
                                } else {
                                  return false;
                                }
                              } else {
                                throw [
                                      Caml_builtin_exceptions.match_failure,
                                      /* tuple */[
                                        "Guesser.re",
                                        108,
                                        24
                                      ]
                                    ];
                              }
                            }))(Caml_array.caml_array_get(memo, j - 1 | 0));
                    return List.map((function (x) {
                                  return /* Application */Block.__(5, [
                                            e,
                                            x
                                          ]);
                                }), candidates);
                  }), funcs));
}

function guess(delta, gamma, typ, i) {
  if (i === 1) {
    var terms = List.filter((function (param) {
              return Caml_obj.caml_equal(param[1][0], typ);
            }))(gamma);
    Caml_array.caml_array_set(memo, 0, Pervasives.$at(/* :: */[
              /* Unit */1,
              /* [] */0
            ], List.map((function (param) {
                    return /* Var */Block.__(7, [param[0]]);
                  }), gamma)));
    return List.map((function (param) {
                  return /* Var */Block.__(7, [param[0]]);
                }), terms);
  }
  var firsts = guessFst(delta, gamma, typ, i);
  var seconds = guessSnd(delta, gamma, typ, i);
  var ctors = guessCtors(delta, gamma, typ, i);
  var pairs = partition(i);
  var apps = List.concat(List.map((function (param) {
              return guessApp(delta, gamma, typ, param[0], param[1]);
            }), pairs));
  Caml_array.caml_array_set(memo, i - 1 | 0, Pervasives.$at(firsts, Pervasives.$at(seconds, Pervasives.$at(ctors, apps))));
  return List.filter((function (e) {
                  return Caml_obj.caml_equal(Typing$MyNewProject.getType(delta, gamma, e), typ);
                }))(Caml_array.caml_array_get(memo, i - 1 | 0));
}

exports.memo = memo;
exports.resetMemo = resetMemo;
exports.partition_h = partition_h;
exports.partition = partition;
exports.guessFst = guessFst;
exports.guessSnd = guessSnd;
exports.guessPairs = guessPairs;
exports.guessCtors = guessCtors;
exports.guessApp = guessApp;
exports.guess = guess;
/* No side effect */
