// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Parser$MyNewProject = require("./Parser.bs.js");
var Solver$MyNewProject = require("./Solver.bs.js");
var Guesser$MyNewProject = require("./Guesser.bs.js");
var Printer$MyNewProject = require("./Printer.bs.js");
var Evaluator$MyNewProject = require("./evaluator.bs.js");
var Unevaluator$MyNewProject = require("./unevaluator.bs.js");

function split(str) {
  var r = function (_inp, _out, _live) {
    while(true) {
      var live = _live;
      var out = _out;
      var inp = _inp;
      if (!inp) {
        return /* tuple */[
                /* [] */0,
                /* :: */[
                  live,
                  out
                ],
                /* [] */0
              ];
      }
      var c = inp[0];
      if (c !== 32) {
        _live = /* :: */[
          c,
          live
        ];
        _inp = inp[1];
        continue ;
      }
      _live = /* [] */0;
      _out = /* :: */[
        live,
        out
      ];
      _inp = inp[1];
      continue ;
    };
  };
  var match = r(List.rev(Parser$MyNewProject.explode(str)), /* [] */0, /* [] */0);
  return List.map(Parser$MyNewProject.implode, match[1]);
}

var history = {
  contents: /* [] */0
};

function $$process(inp, stack, command) {
  history.contents = /* :: */[
    /* :: */[
      /* tuple */[
        command,
        Parser$MyNewProject.implode(inp),
        stack
      ],
      List.hd(history.contents)
    ],
    List.tl(history.contents)
  ];
  var exit = 0;
  switch (command) {
    case "a" :
        var match = Parser$MyNewProject.parse_debug_construct(inp);
        return /* tuple */[
                match[1],
                /* :: */[
                  match[0],
                  stack
                ]
              ];
    case "env" :
        var match$1 = Parser$MyNewProject.parse_environment(inp);
        return /* tuple */[
                match$1[1],
                /* :: */[
                  /* Environment */Block.__(1, [match$1[0]]),
                  stack
                ]
              ];
    case "eval" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v1 = stack[0];
        if (v1.tag) {
          return Pervasives.failwith("Type error");
        }
        var stack$1 = stack[1];
        if (!stack$1) {
          return Pervasives.failwith("Empty stack");
        }
        var v0 = stack$1[0];
        if (v0.tag === /* Environment */1) {
          return /* tuple */[
                  inp,
                  /* :: */[
                    /* Res */Block.__(2, [Evaluator$MyNewProject.$$eval(v0[0], v1[0])]),
                    stack$1[1]
                  ]
                ];
        } else {
          return Pervasives.failwith("Type error");
        }
    case "ex" :
    case "example" :
        exit = 3;
        break;
    case "exp" :
        var match$2 = Parser$MyNewProject.parse_exp(inp);
        return /* tuple */[
                match$2[1],
                /* :: */[
                  /* Exp */Block.__(0, [match$2[0]]),
                  stack
                ]
              ];
    case "context" :
    case "gamma" :
        exit = 1;
        break;
    case "guess" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v3 = stack[0];
        if (v3.tag !== /* DB_Int */8) {
          return Pervasives.failwith("Type error");
        }
        var stack$2 = stack[1];
        if (!stack$2) {
          return Pervasives.failwith("Empty stack");
        }
        var v2 = stack$2[0];
        if (v2.tag !== /* Type_ */3) {
          return Pervasives.failwith("Type error");
        }
        var stack$3 = stack$2[1];
        if (!stack$3) {
          return Pervasives.failwith("Empty stack");
        }
        var v1$1 = stack$3[0];
        if (v1$1.tag !== /* Context */6) {
          return Pervasives.failwith("Type error");
        }
        var stack$4 = stack$3[1];
        if (!stack$4) {
          return Pervasives.failwith("Empty stack");
        }
        var v0$1 = stack$4[0];
        if (v0$1.tag === /* Hole_Context */7) {
          return /* tuple */[
                  inp,
                  /* :: */[
                    /* Guess_Output */Block.__(9, [Guesser$MyNewProject.guess(v0$1[0], v1$1[0], v2[0], v3[0])]),
                    stack$4[1]
                  ]
                ];
        } else {
          return Pervasives.failwith("Type error");
        }
    case "delta" :
    case "hole_context" :
        exit = 2;
        break;
    case "hole_fillings" :
        var match$3 = Parser$MyNewProject.parse_hole_fillings(inp);
        return /* tuple */[
                match$3[1],
                /* :: */[
                  /* Hole_Fillings */Block.__(12, [match$3[0]]),
                  stack
                ]
              ];
    case "int" :
        var match$4 = Parser$MyNewProject.parse_int(inp);
        return /* tuple */[
                match$4[1],
                /* :: */[
                  /* DB_Int */Block.__(8, [match$4[0]]),
                  stack
                ]
              ];
    case "res" :
        var match$5 = Parser$MyNewProject.parse_res(inp);
        return /* tuple */[
                match$5[1],
                /* :: */[
                  /* Res */Block.__(2, [match$5[0]]),
                  stack
                ]
              ];
    case "solve" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v2$1 = stack[0];
        if (v2$1.tag) {
          return Pervasives.failwith("Type error");
        }
        var stack$5 = stack[1];
        if (!stack$5) {
          return Pervasives.failwith("Empty stack");
        }
        var v1$2 = stack$5[0];
        if (v1$2.tag === /* Constraint_ */5) {
          return /* tuple */[
                  inp,
                  /* :: */[
                    /* Solver_Output */Block.__(10, [Solver$MyNewProject.solve(v1$2[0], v2$1[0])]),
                    stack$5[1]
                  ]
                ];
        } else {
          return Pervasives.failwith("Type error");
        }
    case "type" :
        var match$6 = Parser$MyNewProject.parse_type_(inp);
        return /* tuple */[
                match$6[1],
                /* :: */[
                  /* Type_ */Block.__(3, [match$6[0]]),
                  stack
                ]
              ];
    case "uneval" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v2$2 = stack[0];
        if (v2$2.tag !== /* Example */4) {
          return Pervasives.failwith("Type error");
        }
        var stack$6 = stack[1];
        if (!stack$6) {
          return Pervasives.failwith("Empty stack");
        }
        var v1$3 = stack$6[0];
        if (v1$3.tag !== /* Res */2) {
          return Pervasives.failwith("Type error");
        }
        var stack$7 = stack$6[1];
        if (!stack$7) {
          return Pervasives.failwith("Empty stack");
        }
        var v0$2 = stack$7[0];
        if (v0$2.tag === /* Hole_Context */7) {
          return /* tuple */[
                  inp,
                  /* :: */[
                    /* Constraint_ */Block.__(5, [Unevaluator$MyNewProject.unevalInit(v0$2[0], v1$3[0], v2$2[0])]),
                    stack$7[1]
                  ]
                ];
        } else {
          return Pervasives.failwith("Type error");
        }
    case "unevaluate" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v2$3 = stack[0];
        if (v2$3.tag !== /* Example */4) {
          return Pervasives.failwith("Type error");
        }
        var stack$8 = stack[1];
        if (!stack$8) {
          return Pervasives.failwith("Empty stack");
        }
        var v1$4 = stack$8[0];
        if (v1$4.tag !== /* Res */2) {
          return Pervasives.failwith("Type error");
        }
        var stack$9 = stack$8[1];
        if (!stack$9) {
          return Pervasives.failwith("Empty stack");
        }
        var v0$3 = stack$9[0];
        if (v0$3.tag === /* Hole_Context */7) {
          return /* tuple */[
                  inp,
                  /* :: */[
                    /* Constraint_ */Block.__(5, [Unevaluator$MyNewProject.unevalInit(v0$3[0], v1$4[0], v2$3[0])]),
                    stack$9[1]
                  ]
                ];
        } else {
          return Pervasives.failwith("Type error");
        }
    default:
      return Pervasives.failwith("Unknown command: \"" + (command + "\""));
  }
  switch (exit) {
    case 1 :
        var match$7 = Parser$MyNewProject.parse_context(inp);
        return /* tuple */[
                match$7[1],
                /* :: */[
                  /* Context */Block.__(6, [match$7[0]]),
                  stack
                ]
              ];
    case 2 :
        var match$8 = Parser$MyNewProject.parse_hole_context(inp);
        return /* tuple */[
                match$8[1],
                /* :: */[
                  /* Hole_Context */Block.__(7, [match$8[0]]),
                  stack
                ]
              ];
    case 3 :
        var match$9 = Parser$MyNewProject.parse_example(inp);
        return /* tuple */[
                match$9[1],
                /* :: */[
                  /* Example */Block.__(4, [match$9[0]]),
                  stack
                ]
              ];
    
  }
}

function main(inp, commands) {
  var commands$1 = split(commands);
  var inp$1 = Parser$MyNewProject.explode(inp);
  history.contents = /* :: */[
    /* [] */0,
    history.contents
  ];
  var match = List.fold_left((function (param, command) {
          return $$process(param[0], param[1], command);
        }), /* tuple */[
        inp$1,
        /* [] */0
      ], commands$1);
  var stack = match[1];
  var inp$2 = match[0];
  history.contents = /* :: */[
    /* :: */[
      /* tuple */[
        "<print_all>",
        Parser$MyNewProject.implode(inp$2),
        stack
      ],
      List.hd(history.contents)
    ],
    List.tl(history.contents)
  ];
  List.iter((function (construct) {
          console.log(Printer$MyNewProject.string_of_debug_construct(construct));
          
        }), stack);
  var inp$3 = Parser$MyNewProject.implode(inp$2);
  if (inp$3 !== "") {
    console.log("Warning, leftover input: \"" + (inp$3 + "\""));
    return ;
  }
  
}

exports.split = split;
exports.history = history;
exports.$$process = $$process;
exports.main = main;
/* No side effect */
