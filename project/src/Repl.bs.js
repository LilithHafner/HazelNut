// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Parser$MyNewProject = require("./Parser.bs.js");
var Printer$MyNewProject = require("./Printer.bs.js");
var Evaluator$MyNewProject = require("./evaluator.bs.js");

function split(str) {
  var r = function (_inp, _out, _live) {
    while(true) {
      var live = _live;
      var out = _out;
      var inp = _inp;
      if (!inp) {
        return /* tuple */[
                /* [] */0,
                /* :: */[
                  live,
                  out
                ],
                /* [] */0
              ];
      }
      var c = inp[0];
      if (c !== 32) {
        _live = /* :: */[
          c,
          live
        ];
        _inp = inp[1];
        continue ;
      }
      _live = /* [] */0;
      _out = /* :: */[
        live,
        out
      ];
      _inp = inp[1];
      continue ;
    };
  };
  var match = r(List.rev(Parser$MyNewProject.explode(str)), /* [] */0, /* [] */0);
  return List.map(Parser$MyNewProject.implode, match[1]);
}

var history = {
  contents: /* [] */0
};

function $$process(inp, stack, command) {
  history.contents = /* :: */[
    /* :: */[
      /* tuple */[
        command,
        Parser$MyNewProject.implode(inp),
        stack
      ],
      List.hd(history.contents)
    ],
    List.tl(history.contents)
  ];
  switch (command) {
    case "eval" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v1 = stack[0];
        switch (v1.tag | 0) {
          case /* Exp */0 :
              var stack$1 = stack[1];
              if (!stack$1) {
                return Pervasives.failwith("Empty stack");
              }
              var v0 = stack$1[0];
              switch (v0.tag | 0) {
                case /* Environment */1 :
                    return /* tuple */[
                            inp,
                            /* :: */[
                              /* Res */Block.__(2, [Evaluator$MyNewProject.$$eval(v0[0], v1[0])]),
                              stack$1[1]
                            ]
                          ];
                case /* Exp */0 :
                case /* Res */2 :
                    return Pervasives.failwith("Type error");
                
              }
          case /* Environment */1 :
          case /* Res */2 :
              return Pervasives.failwith("Type error");
          
        }
    case "parse_any" :
        var match = Parser$MyNewProject.parse_debug_construct(inp);
        return /* tuple */[
                match[1],
                /* :: */[
                  match[0],
                  stack
                ]
              ];
    default:
      return Pervasives.failwith("Unknown command: \"" + (command + "\""));
  }
}

function main(inp, commands) {
  var commands$1 = split(commands);
  var inp$1 = Parser$MyNewProject.explode(inp);
  history.contents = /* :: */[
    /* [] */0,
    history.contents
  ];
  var match = List.fold_left((function (param, command) {
          return $$process(param[0], param[1], command);
        }), /* tuple */[
        inp$1,
        /* [] */0
      ], commands$1);
  var stack = match[1];
  var inp$2 = match[0];
  history.contents = /* :: */[
    /* :: */[
      /* tuple */[
        "<print_all>",
        Parser$MyNewProject.implode(inp$2),
        stack
      ],
      List.hd(history.contents)
    ],
    List.tl(history.contents)
  ];
  List.iter((function (construct) {
          console.log(Printer$MyNewProject.string_of_debug_construct(construct));
          
        }), stack);
  var inp$3 = Parser$MyNewProject.implode(inp$2);
  if (inp$3 !== "") {
    console.log("Warning, leftover input: \"" + (inp$3 + "\""));
    return ;
  }
  
}

exports.split = split;
exports.history = history;
exports.$$process = $$process;
exports.main = main;
/* No side effect */
