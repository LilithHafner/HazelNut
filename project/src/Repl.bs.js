// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Parser$MyNewProject = require("./Parser.bs.js");
var Printer$MyNewProject = require("./Printer.bs.js");
var Evaluator$MyNewProject = require("./evaluator.bs.js");
var Unevaluator$MyNewProject = require("./unevaluator.bs.js");

function split(str) {
  var r = function (_inp, _out, _live) {
    while(true) {
      var live = _live;
      var out = _out;
      var inp = _inp;
      if (!inp) {
        return /* tuple */[
                /* [] */0,
                /* :: */[
                  live,
                  out
                ],
                /* [] */0
              ];
      }
      var c = inp[0];
      if (c !== 32) {
        _live = /* :: */[
          c,
          live
        ];
        _inp = inp[1];
        continue ;
      }
      _live = /* [] */0;
      _out = /* :: */[
        live,
        out
      ];
      _inp = inp[1];
      continue ;
    };
  };
  var match = r(List.rev(Parser$MyNewProject.explode(str)), /* [] */0, /* [] */0);
  return List.map(Parser$MyNewProject.implode, match[1]);
}

var history = {
  contents: /* [] */0
};

function $$process(inp, stack, command) {
  history.contents = /* :: */[
    /* :: */[
      /* tuple */[
        command,
        Parser$MyNewProject.implode(inp),
        stack
      ],
      List.hd(history.contents)
    ],
    List.tl(history.contents)
  ];
  switch (command) {
    case "a" :
        var match = Parser$MyNewProject.parse_debug_construct(inp);
        return /* tuple */[
                match[1],
                /* :: */[
                  match[0],
                  stack
                ]
              ];
    case "env" :
        var match$1 = Parser$MyNewProject.parse_environment(inp);
        return /* tuple */[
                match$1[1],
                /* :: */[
                  /* Environment */Block.__(1, [match$1[0]]),
                  stack
                ]
              ];
    case "eval" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v1 = stack[0];
        if (v1.tag) {
          return Pervasives.failwith("Type error");
        }
        var stack$1 = stack[1];
        if (!stack$1) {
          return Pervasives.failwith("Empty stack");
        }
        var v0 = stack$1[0];
        if (v0.tag === /* Environment */1) {
          return /* tuple */[
                  inp,
                  /* :: */[
                    /* Res */Block.__(2, [Evaluator$MyNewProject.$$eval(v0[0], v1[0])]),
                    stack$1[1]
                  ]
                ];
        } else {
          return Pervasives.failwith("Type error");
        }
    case "ex" :
        var match$2 = Parser$MyNewProject.parse_example(inp);
        return /* tuple */[
                match$2[1],
                /* :: */[
                  /* Example */Block.__(4, [match$2[0]]),
                  stack
                ]
              ];
    case "exp" :
        var match$3 = Parser$MyNewProject.parse_exp(inp);
        return /* tuple */[
                match$3[1],
                /* :: */[
                  /* Exp */Block.__(0, [match$3[0]]),
                  stack
                ]
              ];
    case "res" :
        var match$4 = Parser$MyNewProject.parse_res(inp);
        return /* tuple */[
                match$4[1],
                /* :: */[
                  /* Res */Block.__(2, [match$4[0]]),
                  stack
                ]
              ];
    case "type" :
        var match$5 = Parser$MyNewProject.parse_type_(inp);
        return /* tuple */[
                match$5[1],
                /* :: */[
                  /* Type_ */Block.__(3, [match$5[0]]),
                  stack
                ]
              ];
    case "uneval" :
        if (!stack) {
          return Pervasives.failwith("Empty stack");
        }
        var v1$1 = stack[0];
        if (v1$1.tag !== /* Example */4) {
          return Pervasives.failwith("Type error");
        }
        var stack$2 = stack[1];
        if (!stack$2) {
          return Pervasives.failwith("Empty stack");
        }
        var v0$1 = stack$2[0];
        if (v0$1.tag === /* Res */2) {
          return /* tuple */[
                  inp,
                  /* :: */[
                    /* Constraint_ */Block.__(5, [Unevaluator$MyNewProject.unevaluate(v0$1[0], v1$1[0])]),
                    stack$2[1]
                  ]
                ];
        } else {
          return Pervasives.failwith("Type error");
        }
    default:
      return Pervasives.failwith("Unknown command: \"" + (command + "\""));
  }
}

function main(inp, commands) {
  var commands$1 = split(commands);
  var inp$1 = Parser$MyNewProject.explode(inp);
  history.contents = /* :: */[
    /* [] */0,
    history.contents
  ];
  var match = List.fold_left((function (param, command) {
          return $$process(param[0], param[1], command);
        }), /* tuple */[
        inp$1,
        /* [] */0
      ], commands$1);
  var stack = match[1];
  var inp$2 = match[0];
  history.contents = /* :: */[
    /* :: */[
      /* tuple */[
        "<print_all>",
        Parser$MyNewProject.implode(inp$2),
        stack
      ],
      List.hd(history.contents)
    ],
    List.tl(history.contents)
  ];
  List.iter((function (construct) {
          console.log(Printer$MyNewProject.string_of_debug_construct(construct));
          
        }), stack);
  var inp$3 = Parser$MyNewProject.implode(inp$2);
  if (inp$3 !== "") {
    console.log("Warning, leftover input: \"" + (inp$3 + "\""));
    return ;
  }
  
}

exports.split = split;
exports.history = history;
exports.$$process = $$process;
exports.main = main;
/* No side effect */
