// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Tools$MyNewProject = require("./Tools.bs.js");
var Types$MyNewProject = require("./Types.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function getType(delta, gamma, _e) {
  while(true) {
    var e = _e;
    if (typeof e === "number") {
      if (e === /* Nil */0) {
        return /* Any_t */3;
      } else {
        return /* Unit_t */2;
      }
    }
    switch (e.tag | 0) {
      case /* Int */0 :
          return /* Int_t */0;
      case /* Float */1 :
          return /* Any_t */3;
      case /* Bool */2 :
          return /* Bool_t */1;
      case /* Cons */3 :
          return /* Cons_t */Block.__(0, [
                    getType(delta, gamma, e[0]),
                    getType(delta, gamma, e[1])
                  ]);
      case /* Function */4 :
          return /* Function_t */Block.__(1, [
                    e[2],
                    getType(delta, gamma, e[3])
                  ]);
      case /* Application */5 :
          var x = getType(delta, gamma, e[0]);
          if (typeof x === "number" || !(x.tag === /* Function_t */1 && Caml_obj.caml_equal(getType(delta, gamma, e[1]), x[0]))) {
            return Pervasives.failwith("Application type error");
          } else {
            return x[1];
          }
      case /* Hole */6 :
          return Tools$MyNewProject.lookup(e[0], delta)[1];
      case /* Var */7 :
          return Tools$MyNewProject.lookup(e[0], gamma)[0];
      case /* Pair */8 :
          return /* Pair_t */Block.__(2, [
                    getType(delta, gamma, e[0]),
                    getType(delta, gamma, e[1])
                  ]);
      case /* Fst */9 :
          var match = getType(delta, gamma, e[0]);
          if (typeof match === "number" || match.tag !== /* Pair_t */2) {
            return Pervasives.failwith("Type error: Expected type pair for fst");
          } else {
            return match[0];
          }
      case /* Snd */10 :
          var match$1 = getType(delta, gamma, e[0]);
          if (typeof match$1 === "number" || match$1.tag !== /* Pair_t */2) {
            return Pervasives.failwith("Type error: Expected type pair for snd");
          } else {
            return match$1[1];
          }
      case /* Ctor */11 :
          var d = e[1];
          if (Caml_obj.caml_equal(Tools$MyNewProject.lookup(e[0], Tools$MyNewProject.lookup(d, Types$MyNewProject.sigma)), getType(delta, gamma, e[2]))) {
            return /* D */Block.__(3, [d]);
          } else {
            return Pervasives.failwith("Constructor did not typecheck");
          }
      case /* Case */12 :
          var branches = e[1];
          if (!branches) {
            return Pervasives.failwith("No branches supplied to case");
          }
          _e = branches[0][1][1];
          continue ;
      
    }
  };
}

function getResType(delta, _r) {
  while(true) {
    var r = _r;
    if (typeof r === "number") {
      if (r === /* Rnil */0) {
        return Pervasives.failwith("Not yet implemented");
      } else {
        return /* Unit_t */2;
      }
    }
    switch (r.tag | 0) {
      case /* Rint */0 :
          return /* Int_t */0;
      case /* Rfloat */1 :
          return /* Any_t */3;
      case /* Rbool */2 :
          return /* Bool_t */1;
      case /* Rcons */3 :
          return Pervasives.failwith("Not yet implemented");
      case /* Rfunc */4 :
          return getType(delta, generateContext(delta, r[4]), /* Function */Block.__(4, [
                        r[0],
                        r[1],
                        r[2],
                        r[3]
                      ]));
      case /* Rapp */5 :
          var match = getResType(delta, r[0]);
          if (typeof match === "number" || !(match.tag === /* Function_t */1 && Caml_obj.caml_equal(match[0], getResType(delta, r[1])))) {
            return Pervasives.failwith("Type error, failed application");
          } else {
            return match[1];
          }
      case /* Rhole */6 :
          var match$1 = Tools$MyNewProject.lookup(r[0], delta);
          if (Caml_obj.caml_equal(match$1[0], generateContext(delta, r[1]))) {
            return match$1[1];
          } else {
            return Pervasives.failwith("Type error: hole context doesn't match environment context");
          }
      case /* Rpair */7 :
          return /* Pair_t */Block.__(2, [
                    getResType(delta, r[0]),
                    getResType(delta, r[1])
                  ]);
      case /* Rfst */8 :
          var r$prime = r[0];
          if (typeof r$prime === "number") {
            return Pervasives.failwith("Type error: Exppected pair");
          }
          if (r$prime.tag !== /* Rpair */7) {
            return Pervasives.failwith("Type error: Exppected pair");
          }
          _r = r$prime[0];
          continue ;
      case /* Rsnd */9 :
          var r$prime$1 = r[0];
          if (typeof r$prime$1 === "number") {
            return Pervasives.failwith("Type error: Exppected pair");
          }
          if (r$prime$1.tag !== /* Rpair */7) {
            return Pervasives.failwith("Type error: Exppected pair");
          }
          _r = r$prime$1[1];
          continue ;
      case /* Rctor */10 :
          var adt = r[1];
          if (Caml_obj.caml_equal(Tools$MyNewProject.lookup(r[0], Tools$MyNewProject.lookup(adt, Types$MyNewProject.sigma)), getResType(delta, r[2]))) {
            return /* D */Block.__(3, [adt]);
          } else {
            return Pervasives.failwith("Type error: Result type doesn't match constructor type");
          }
      case /* Rictor */11 :
          _r = r[2];
          continue ;
      case /* Rcase */12 :
          var bs = r[1];
          var d = getResType(delta, r[0]);
          if (typeof d === "number") {
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "Typing.re",
                    93,
                    16
                  ]
                ];
          }
          if (d.tag === /* D */3) {
            var gamma = generateContext(delta, r[2]);
            if (!bs) {
              return /* Any_t */3;
            }
            var xs = bs[1];
            var t = Tools$MyNewProject.lookup(bs[0][0], Tools$MyNewProject.lookup(d[0], Types$MyNewProject.sigma));
            if (Caml_obj.caml_equal(List.filter((function(gamma,t){
                        return function (param) {
                          return Caml_obj.caml_equal(getType(delta, gamma, param[1][1]), t);
                        }
                        }(gamma,t)))(xs), xs)) {
              return t;
            } else {
              return Pervasives.failwith("Not all branches have the same type");
            }
          }
          throw [
                Caml_builtin_exceptions.match_failure,
                /* tuple */[
                  "Typing.re",
                  93,
                  16
                ]
              ];
      
    }
  };
}

function generateContext(delta, env) {
  if (!env) {
    return /* [] */0;
  }
  var match = env[0];
  return /* :: */[
          /* tuple */[
            match[0],
            /* tuple */[
              getResType(delta, match[1]),
              /* AnnNone */0
            ]
          ],
          generateContext(delta, env[1])
        ];
}

function getExType(delta, ex) {
  if (typeof ex === "number") {
    if (ex === /* Top */0) {
      return /* Any_t */3;
    } else {
      return /* Unit_t */2;
    }
  }
  switch (ex.tag | 0) {
    case /* Eint */0 :
        return /* Int_t */0;
    case /* Ebool */1 :
        return /* Bool_t */1;
    case /* Epair */2 :
        return /* Pair_t */Block.__(2, [
                  getExType(delta, ex[0]),
                  getExType(delta, ex[1])
                ]);
    case /* Efunc */3 :
        return /* Function_t */Block.__(1, [
                  getResType(delta, Types$MyNewProject.valToRes(ex[0])),
                  getExType(delta, ex[1])
                ]);
    case /* Ector */4 :
        var adt = ex[1];
        var t = Tools$MyNewProject.lookup(ex[0], Tools$MyNewProject.lookup(adt, Types$MyNewProject.sigma));
        if (Caml_obj.caml_equal(t, getExType(delta, ex[2]))) {
          return /* D */Block.__(3, [adt]);
        } else {
          return Pervasives.failwith("Type error: Example doesn't have type required by example constructor");
        }
    
  }
}

function getConstraintType(delta, exs) {
  var contexts = List.map((function (param) {
          return /* tuple */[
                  generateContext(delta, param[0]),
                  getExType(delta, param[1])
                ];
        }), exs);
  if (!contexts) {
    return /* tuple */[
            /* [] */0,
            /* Any_t */3
          ];
  }
  var x = contexts[0];
  var match = List.filter((function (y) {
            return Caml_obj.caml_notequal(x, y);
          }))(contexts);
  if (match) {
    return Pervasives.failwith("Contexts are not consistent for set of example constraints");
  } else {
    return x;
  }
}

function generateHoleContextU_h(_delta, _us) {
  while(true) {
    var us = _us;
    var delta = _delta;
    if (!us) {
      return delta;
    }
    var match = us[0];
    _us = us[1];
    _delta = /* :: */[
      /* tuple */[
        match[0],
        getConstraintType(delta, match[1])
      ],
      delta
    ];
    continue ;
  };
}

function generateHoleContextU(us) {
  return generateHoleContextU_h(/* [] */0, List.rev(us));
}

function generateHoleContextF(fs) {
  return /* [] */0;
}

exports.getType = getType;
exports.getResType = getResType;
exports.generateContext = generateContext;
exports.getExType = getExType;
exports.getConstraintType = getConstraintType;
exports.generateHoleContextU_h = generateHoleContextU_h;
exports.generateHoleContextU = generateHoleContextU;
exports.generateHoleContextF = generateHoleContextF;
/* No side effect */
