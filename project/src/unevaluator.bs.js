// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Types$MyNewProject = require("./Types.bs.js");
var Evaluator$MyNewProject = require("./evaluator.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function unevaluate(_res, _ex) {
  while(true) {
    var ex = _ex;
    var res = _res;
    if (typeof ex === "number") {
      if (ex === /* Top */0) {
        return /* [] */0;
      }
      if (typeof res === "number") {
        if (res === /* Runit */1) {
          return /* [] */0;
        } else {
          return ;
        }
      }
      switch (res.tag | 0) {
        case /* Rapp */5 :
        case /* Rhole */6 :
        case /* Rfst */8 :
        case /* Rsnd */9 :
            break;
        default:
          return ;
      }
    } else if (ex.tag) {
      if (typeof res === "number") {
        return ;
      }
      switch (res.tag | 0) {
        case /* Rfunc */4 :
            var env$prime_000 = /* tuple */[
              res[0],
              Types$MyNewProject.valToRes(ex[0])
            ];
            var env$prime_001 = res[2];
            var env$prime = /* :: */[
              env$prime_000,
              env$prime_001
            ];
            var exs_000 = /* tuple */[
              env$prime,
              ex[1]
            ];
            var exs = /* :: */[
              exs_000,
              /* [] */0
            ];
            return constrainExp(res[1], exs);
        case /* Rapp */5 :
        case /* Rhole */6 :
        case /* Rfst */8 :
        case /* Rsnd */9 :
            break;
        default:
          return ;
      }
    } else {
      if (typeof res === "number") {
        return ;
      }
      switch (res.tag | 0) {
        case /* Rpair */7 :
            var match = unevaluate(res[0], ex[0]);
            var match$1 = unevaluate(res[1], ex[1]);
            if (match !== undefined && match$1 !== undefined) {
              return List.concat(/* :: */[
                          match,
                          /* :: */[
                            match$1,
                            /* [] */0
                          ]
                        ]);
            } else {
              return ;
            }
        case /* Rapp */5 :
        case /* Rhole */6 :
        case /* Rfst */8 :
        case /* Rsnd */9 :
            break;
        default:
          return ;
      }
    }
    if (typeof res !== "number") {
      switch (res.tag | 0) {
        case /* Rapp */5 :
            var r2 = res[1];
            if (!Types$MyNewProject.castable(r2)) {
              return ;
            }
            var v = Types$MyNewProject.resToVal(r2);
            if (v !== undefined) {
              _ex = /* Efunc */Block.__(1, [
                  v,
                  ex
                ]);
              _res = res[0];
              continue ;
            }
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "unevaluator.re",
                    37,
                    20
                  ]
                ];
        case /* Rhole */6 :
            return /* :: */[
                    /* tuple */[
                      res[1],
                      /* tuple */[
                        res[0],
                        ex
                      ]
                    ],
                    /* [] */0
                  ];
        case /* Rfst */8 :
            _ex = /* Epair */Block.__(0, [
                ex,
                /* Top */0
              ]);
            _res = res[0];
            continue ;
        case /* Rsnd */9 :
            _ex = /* Epair */Block.__(0, [
                /* Top */0,
                ex
              ]);
            _res = res[0];
            continue ;
        
      }
    }
    
  };
}

function constrainExp(exp, exs) {
  if (!exs) {
    return /* [] */0;
  }
  var match = exs[0];
  var match$1 = constrainExp(exp, exs[1]);
  var match$2 = unevaluate(Evaluator$MyNewProject.$$eval(match[0], exp), match[1]);
  if (match$1 !== undefined && match$2 !== undefined) {
    return List.concat(/* :: */[
                match$1,
                /* :: */[
                  match$2,
                  /* [] */0
                ]
              ]);
  }
  
}

exports.unevaluate = unevaluate;
exports.constrainExp = constrainExp;
/* No side effect */
