// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Types$MyNewProject = require("./Types.bs.js");
var Evaluator$MyNewProject = require("./evaluator.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function unevaluate(_res, _ex) {
  while(true) {
    var ex = _ex;
    var res = _res;
    if (typeof ex === "number") {
      if (ex === /* Top */0) {
        return /* tuple */[
                /* [] */0,
                /* [] */0
              ];
      }
      if (typeof res === "number") {
        if (res === /* Runit */1) {
          return /* tuple */[
                  /* [] */0,
                  /* [] */0
                ];
        } else {
          return ;
        }
      }
      switch (res.tag | 0) {
        case /* Rapp */5 :
        case /* Rhole */6 :
        case /* Rfst */8 :
        case /* Rsnd */9 :
            break;
        default:
          return ;
      }
    } else {
      switch (ex.tag | 0) {
        case /* Eint */0 :
            if (typeof res === "number") {
              return ;
            }
            switch (res.tag | 0) {
              case /* Rint */0 :
                  if (ex[0] === res[0]) {
                    return /* tuple */[
                            /* [] */0,
                            /* [] */0
                          ];
                  } else {
                    return ;
                  }
              case /* Rapp */5 :
              case /* Rhole */6 :
              case /* Rfst */8 :
              case /* Rsnd */9 :
                  break;
              default:
                return ;
            }
            break;
        case /* Ebool */1 :
            if (typeof res === "number") {
              return ;
            }
            switch (res.tag | 0) {
              case /* Rbool */2 :
                  if (ex[0] === res[0]) {
                    return /* tuple */[
                            /* [] */0,
                            /* [] */0
                          ];
                  } else {
                    return ;
                  }
              case /* Rapp */5 :
              case /* Rhole */6 :
              case /* Rfst */8 :
              case /* Rsnd */9 :
                  break;
              default:
                return ;
            }
            break;
        case /* Epair */2 :
            if (typeof res === "number") {
              return ;
            }
            switch (res.tag | 0) {
              case /* Rpair */7 :
                  var match = unevaluate(res[0], ex[0]);
                  var match$1 = unevaluate(res[1], ex[1]);
                  if (match !== undefined && match$1 !== undefined) {
                    return /* tuple */[
                            List.concat(/* :: */[
                                  match[0],
                                  /* :: */[
                                    match$1[0],
                                    /* [] */0
                                  ]
                                ]),
                            /* [] */0
                          ];
                  } else {
                    return ;
                  }
              case /* Rapp */5 :
              case /* Rhole */6 :
              case /* Rfst */8 :
              case /* Rsnd */9 :
                  break;
              default:
                return ;
            }
            break;
        case /* Efunc */3 :
            if (typeof res === "number") {
              return ;
            }
            switch (res.tag | 0) {
              case /* Rfunc */4 :
                  var env$prime_000 = /* tuple */[
                    res[0],
                    Types$MyNewProject.valToRes(ex[0])
                  ];
                  var env$prime_001 = res[2];
                  var env$prime = /* :: */[
                    env$prime_000,
                    env$prime_001
                  ];
                  var exs_000 = /* tuple */[
                    env$prime,
                    ex[1]
                  ];
                  var exs = /* :: */[
                    exs_000,
                    /* [] */0
                  ];
                  return constrainExp(res[1], exs);
              case /* Rapp */5 :
              case /* Rhole */6 :
              case /* Rfst */8 :
              case /* Rsnd */9 :
                  break;
              default:
                return ;
            }
            break;
        
      }
    }
    if (typeof res !== "number") {
      switch (res.tag | 0) {
        case /* Rapp */5 :
            var r2 = res[1];
            if (!Types$MyNewProject.castable(r2)) {
              return ;
            }
            var v = Types$MyNewProject.resToVal(r2);
            if (v !== undefined) {
              _ex = /* Efunc */Block.__(3, [
                  v,
                  ex
                ]);
              _res = res[0];
              continue ;
            }
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "unevaluator.re",
                    45,
                    20
                  ]
                ];
        case /* Rhole */6 :
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        res[0],
                        /* :: */[
                          /* tuple */[
                            res[1],
                            ex
                          ],
                          /* [] */0
                        ]
                      ],
                      /* [] */0
                    ],
                    /* [] */0
                  ];
        case /* Rfst */8 :
            _ex = /* Epair */Block.__(2, [
                ex,
                /* Top */0
              ]);
            _res = res[0];
            continue ;
        case /* Rsnd */9 :
            _ex = /* Epair */Block.__(2, [
                /* Top */0,
                ex
              ]);
            _res = res[0];
            continue ;
        
      }
    }
    
  };
}

function constrainExp(exp, exs) {
  if (!exs) {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
  var match = exs[0];
  var match$1 = constrainExp(exp, exs[1]);
  var match$2 = unevaluate(Evaluator$MyNewProject.$$eval(match[0], exp), match[1]);
  if (match$1 !== undefined && match$2 !== undefined) {
    return /* tuple */[
            List.concat(/* :: */[
                  match$1[0],
                  /* :: */[
                    match$2[0],
                    /* [] */0
                  ]
                ]),
            /* [] */0
          ];
  }
  
}

exports.unevaluate = unevaluate;
exports.constrainExp = constrainExp;
/* No side effect */
