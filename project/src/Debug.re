open Types;
open Parser;

type construct = debug_construct;

let rec string_of_construct (c:construct):string =
    switch(c) {
        | Exp(x) => string_of_exp(x)
        | Environment(x) => string_of_env(x)
        | Res(x) => string_of_res(x)
    }
and string_of_exp(e:exp):string =
    switch(e) {
        | Int(int) => string_of_int(int)
        | Float(float) => Js.Float.toString(float)
        | Bool(bool) => string_of_bool(bool)
        | Cons(exp, exp2) => string_of_exp(exp) ++ "::" ++ string_of_exp(exp2)
        | Nil  => "Nil"
        | Variable(identifier) => string_of_identifier(identifier)
        | Function(identifier, exp) => "\\" ++ string_of_identifier(identifier) ++ "." ++ string_of_exp(exp)
        | Application(exp, exp2) => string_of_exp(exp) ++ " " ++ string_of_exp(exp2)
        | Hole(hole_identifier) => "??_"++string_of_hole_identifier(hole_identifier)
        | Unit  => "()"
        | Var(identifier) => string_of_identifier(identifier)
        | Pair(exp, exp2) => "(" ++ string_of_exp(exp) ++ ", " ++ string_of_exp(exp2) ++ ")"
        | Fst(exp) => "fst(" ++ string_of_exp(exp) ++ ")"
        | Snd(exp) => "snd(" ++ string_of_exp(exp) ++ ")"
    }
and string_of_res(r:res):string =
    switch(r) {
        | Rint(int) => string_of_int(int)
        | Rfloat(float) => Js.Float.toString(float)
        | Rbool(bool) => string_of_bool(bool)
        | Rcons(res, res2) => string_of_res(res) ++ "::" ++ string_of_res(res2)
        | Rnil  => "Nil"
        | Rfunc(identifier, exp, environment) => "["++string_of_env(environment)++"]\\" ++ string_of_identifier(identifier) ++ "." ++ string_of_exp(exp)
        | Rapp(res, res2) => string_of_res(res) ++ " " ++ string_of_res(res2)
        | Rhole(hole_identifier, environment) => "["++string_of_env(environment)++"]??_"++string_of_hole_identifier(hole_identifier)
        | Runit  => "()"
        | Rpair(res, res2) => "(" ++ string_of_res(res) ++ ", " ++ string_of_res(res2) ++ ")"
        | Rfst(res) => "fst(" ++ string_of_res(res) ++ ")"
        | Rsnd(res) => "snd(" ++ string_of_res(res) ++ ")"
    }
and string_of_env(e:environment):string =
    switch(e) {
        | [] => "-"
        | [(identifier,res),...ms] => string_of_identifier(identifier) ++"->"++string_of_res(res)++"; "++string_of_env(ms)
    }
and string_of_identifier = string_of_int
and string_of_hole_identifier = string_of_int
/* 
//This is because I coudln't find List.make or List.create
let make_list (n:int, f:int=>'a):list('a) = {
    let out = ref([]);
    for (i in n-1 downto 0) {
        out := [f(i), ...out^]
    }
    out^
}

let explode(str:string):list(char) = 
//This is because I coudln't find String.to_seq
//    str |> String.to_seq |> List.of_seq 
    make_list(String.length(str), String.get(str))
let implode(cs:list(char)):string = 
//Because runtime doesn't matter
    String.init(List.length(cs), List.nth(cs))

/* let rec parse_token(x) = {
    let rec parse_token_r(x, y) = {
        switch(x) {
        | [',' | ')', ...x] => (x, y)
        | [c, ...x] => parse_token_r(x,[c,...y])
        | _ => (x,y)
        };
    }
    let (x,y) = parse_token_r(x,[]);
    (implode(List.rev(y)), x)
}
and parse_int(x) = {
    let (v0, x) = parse_token(x);
    (int_of_string(v0), x)
}
and parse_exp(x) = 
    switch(x) {
    | ['h', ...x] => 
        let (v0, x) = parse_int(x);
        (Hole(v0), x)
    | ['v', 'a', 'r', ...x] => 
        let (v0, x) = parse_int(x);
        (Variable(v0), x)
    | ['a', 'p', 'l', ...x] => 
        let (v0, x) = parse_exp(x);
        let (v1, x) = parse_exp(x);
        (Application(v0, v1), x)
    | _ => (Variable(-17), [])
    } */
    let rec parse_token(x) = {
        let rec parse_token_r(x, y) = {
            switch(x) {
            | [',' | ')', ...x] => (x, y)
            | [c, ...x] => parse_token_r(x,[c,...y])
            | _ => (x,y)
            };
        }
        let (x,y) = parse_token_r(x,[]);
        (implode(List.rev(y)), x)
    }
    and parse_exp(x) = 
        switch(x) {
        | ['h', ...x] =>
            let (v0, x) = parse_int(x);
            (Hole(v0), x)
        | ['v', 'a', 'r', ...x] =>
            let (v0, x) = parse_int(x);
            (Variable(v0), x)
        | _ => failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an exp, I got \"" ++ implode(x) ++ "\" which doesn't match any of the expected values: ['h', 'var']")
        }
    and parse_int(x) = {
        let(v0, x) = parse_token(x);
        (int_of_string(v0), x)
    } */



/* let rec infer_types (ert_exp:ert_exp, env:environment):value = { */

Js.log("Hello, BuckleScript and Reason!");



Readline.readline((inp) => {
    //Js.log(inp);
    let (construct, _) = parse_debug_construct(explode(inp));
    Js.log(string_of_construct(construct));
});


/*

#mod_use "Tools.re";







*/