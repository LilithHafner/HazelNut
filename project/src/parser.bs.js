// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function make_list(n, f) {
  var out = /* [] */0;
  for(var i = n - 1 | 0; i >= 0; --i){
    out = /* :: */[
      Curry._1(f, i),
      out
    ];
  }
  return out;
}

function explode(str) {
  return make_list(str.length, (function (param) {
                return Caml_string.get(str, param);
              }));
}

function implode(cs) {
  return $$String.init(List.length(cs), (function (param) {
                return List.nth(cs, param);
              }));
}

function parse_token(x) {
  var parse_token_r = function (_x, _y) {
    while(true) {
      var y = _y;
      var x = _x;
      if (!x) {
        return /* tuple */[
                x,
                y
              ];
      }
      var match = x[0];
      if (match >= 48) {
        if (match >= 58) {
          return /* tuple */[
                  x,
                  y
                ];
        }
        
      } else if (match !== 46) {
        return /* tuple */[
                x,
                y
              ];
      }
      _y = /* :: */[
        List.hd(x),
        y
      ];
      _x = List.tl(x);
      continue ;
    };
  };
  var match = parse_token_r(x, /* [] */0);
  return /* tuple */[
          implode(List.rev(match[1])),
          match[0]
        ];
}

function parse_type_(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 97 :
              return /* tuple */[
                      /* Any_t */3,
                      x[1]
                    ];
          case 98 :
              return /* tuple */[
                      /* Bool_t */1,
                      x[1]
                    ];
          case 99 :
              var match$1 = parse_type_(x[1]);
              var match$2 = parse_type_(match$1[1]);
              return /* tuple */[
                      /* Cons_t */Block.__(0, [
                          match$1[0],
                          match$2[0]
                        ]),
                      match$2[1]
                    ];
          case 100 :
              var match$3 = parse_adt(x[1]);
              return /* tuple */[
                      /* D */Block.__(3, [match$3[0]]),
                      match$3[1]
                    ];
          case 102 :
              var x$1 = x[1];
              var exit = 0;
              if (x$1 && x$1[0] === 97) {
                var match$4 = x$1[1];
                if (match$4 && match$4[0] === 105) {
                  var match$5 = match$4[1];
                  if (match$5) {
                    if (match$5[0] === 108) {
                      return /* tuple */[
                              /* Fail_t */4,
                              match$5[1]
                            ];
                    }
                    exit = 2;
                  } else {
                    exit = 2;
                  }
                } else {
                  exit = 2;
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                var match$6 = parse_type_(x$1);
                var match$7 = parse_type_(match$6[1]);
                return /* tuple */[
                        /* Function_t */Block.__(1, [
                            match$6[0],
                            match$7[0]
                          ]),
                        match$7[1]
                      ];
              }
              break;
          case 105 :
              return /* tuple */[
                      /* Int_t */0,
                      x[1]
                    ];
          case 112 :
              var match$8 = parse_type_(x[1]);
              var match$9 = parse_type_(match$8[1]);
              return /* tuple */[
                      /* Pair_t */Block.__(2, [
                          match$8[0],
                          match$9[0]
                        ]),
                      match$9[1]
                    ];
          case 101 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
              break;
          case 117 :
              return /* tuple */[
                      /* Unit_t */2,
                      x[1]
                    ];
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an type_, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['fail', 'i', 'b', 'c', 'f', 'u', 'p', 'a', 'd']"));
  };
}

function parse_int(x) {
  var match = parse_token(x);
  return /* tuple */[
          Caml_format.caml_int_of_string(match[0]),
          match[1]
        ];
}

function parse_hole_context(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
    var match = x[0];
    if (match >= 11) {
      switch (match) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            break;
        case 59 :
            return /* tuple */[
                    /* [] */0,
                    x[1]
                  ];
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 42 :
        case 43 :
        case 46 :
        case 47 :
        case 58 :
        case 61 :
            return /* tuple */[
                    /* [] */0,
                    x
                  ];
        case 32 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
        case 60 :
        case 62 :
            _x = x[1];
            continue ;
        default:
          return /* tuple */[
                  /* [] */0,
                  x
                ];
      }
    } else {
      if (match < 9) {
        return /* tuple */[
                /* [] */0,
                x
              ];
      }
      _x = x[1];
      continue ;
    }
    var match$1 = parse_int(x);
    var match$2 = parse_context(match$1[1]);
    var match$3 = parse_type_(match$2[1]);
    var match$4 = parse_hole_context(match$3[1]);
    return /* tuple */[
            /* :: */[
              /* tuple */[
                match$1[0],
                /* tuple */[
                  match$2[0],
                  match$3[0]
                ]
              ],
              match$4[0]
            ],
            match$4[1]
          ];
  };
}

function parse_context(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
    var match = x[0];
    if (match >= 11) {
      switch (match) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            break;
        case 59 :
            return /* tuple */[
                    /* [] */0,
                    x[1]
                  ];
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 42 :
        case 43 :
        case 46 :
        case 47 :
        case 58 :
        case 61 :
            return /* tuple */[
                    /* [] */0,
                    x
                  ];
        case 32 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
        case 60 :
        case 62 :
            _x = x[1];
            continue ;
        default:
          return /* tuple */[
                  /* [] */0,
                  x
                ];
      }
    } else {
      if (match < 9) {
        return /* tuple */[
                /* [] */0,
                x
              ];
      }
      _x = x[1];
      continue ;
    }
    var match$1 = parse_int(x);
    var match$2 = parse_type_(match$1[1]);
    var match$3 = parse_context(match$2[1]);
    return /* tuple */[
            /* :: */[
              /* tuple */[
                match$1[0],
                match$2[0]
              ],
              match$3[0]
            ],
            match$3[1]
          ];
  };
}

function parse_excons(x) {
  parse_token(x);
  return Pervasives.failwith("excons_of_string Not Implemented");
}

function parse_unevalcons(x) {
  parse_token(x);
  return Pervasives.failwith("unevalcons_of_string Not Implemented");
}

function parse_unfilled_holes(x) {
  parse_token(x);
  return Pervasives.failwith("unfilled_holes_of_string Not Implemented");
}

function parse_filler_output(x) {
  parse_token(x);
  return Pervasives.failwith("filler_output_of_string Not Implemented");
}

function parse_environment(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
    var match = x[0];
    if (match >= 11) {
      switch (match) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            break;
        case 59 :
            return /* tuple */[
                    /* [] */0,
                    x[1]
                  ];
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 42 :
        case 43 :
        case 46 :
        case 47 :
        case 58 :
        case 61 :
            return /* tuple */[
                    /* [] */0,
                    x
                  ];
        case 32 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
        case 60 :
        case 62 :
            _x = x[1];
            continue ;
        default:
          return /* tuple */[
                  /* [] */0,
                  x
                ];
      }
    } else {
      if (match < 9) {
        return /* tuple */[
                /* [] */0,
                x
              ];
      }
      _x = x[1];
      continue ;
    }
    var match$1 = parse_int(x);
    var match$2 = parse_res(match$1[1]);
    var match$3 = parse_environment(match$2[1]);
    return /* tuple */[
            /* :: */[
              /* tuple */[
                match$1[0],
                match$2[0]
              ],
              match$3[0]
            ],
            match$3[1]
          ];
  };
}

function parse_example(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 98 :
              var match$1 = parse_bool(x[1]);
              return /* tuple */[
                      /* Ebool */Block.__(1, [match$1[0]]),
                      match$1[1]
                    ];
          case 99 :
              var match$2 = parse_int(x[1]);
              var match$3 = parse_example(match$2[1]);
              return /* tuple */[
                      /* Ector */Block.__(4, [
                          match$2[0],
                          match$3[0]
                        ]),
                      match$3[1]
                    ];
          case 102 :
              var match$4 = parse_value(x[1]);
              var match$5 = parse_example(match$4[1]);
              return /* tuple */[
                      /* Efunc */Block.__(3, [
                          match$4[0],
                          match$5[0]
                        ]),
                      match$5[1]
                    ];
          case 105 :
              var match$6 = parse_int(x[1]);
              return /* tuple */[
                      /* Eint */Block.__(0, [match$6[0]]),
                      match$6[1]
                    ];
          case 112 :
              var match$7 = parse_example(x[1]);
              var match$8 = parse_example(match$7[1]);
              return /* tuple */[
                      /* Epair */Block.__(2, [
                          match$7[0],
                          match$8[0]
                        ]),
                      match$8[1]
                    ];
          case 100 :
          case 101 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 113 :
          case 114 :
          case 115 :
              break;
          case 116 :
              return /* tuple */[
                      /* Top */0,
                      x[1]
                    ];
          case 117 :
              return /* tuple */[
                      /* Eunit */1,
                      x[1]
                    ];
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an example, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['t', 'u', 'i', 'b', 'p', 'f', 'c']"));
  };
}

function parse_hole_fillings(x) {
  parse_token(x);
  return Pervasives.failwith("hole_fillings_of_string Not Implemented");
}

function parse_exp(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match >= 11) {
        switch (match) {
          case 32 :
          case 40 :
          case 41 :
          case 44 :
          case 45 :
          case 60 :
          case 62 :
              _x = x[1];
              continue ;
          case 92 :
              var match$1 = parse_int(x[1]);
              var match$2 = parse_type_(match$1[1]);
              var match$3 = parse_exp(match$2[1]);
              return /* tuple */[
                      /* Function */Block.__(4, [
                          match$1[0],
                          match$2[0],
                          match$3[0]
                        ]),
                      match$3[1]
                    ];
          case 97 :
              var match$4 = parse_exp(x[1]);
              var match$5 = parse_exp(match$4[1]);
              return /* tuple */[
                      /* Application */Block.__(5, [
                          match$4[0],
                          match$5[0]
                        ]),
                      match$5[1]
                    ];
          case 98 :
              var match$6 = parse_bool(x[1]);
              return /* tuple */[
                      /* Bool */Block.__(2, [match$6[0]]),
                      match$6[1]
                    ];
          case 99 :
              var x$1 = x[1];
              var exit = 0;
              if (x$1) {
                var match$7 = x$1[0];
                if (match$7 !== 97) {
                  if (match$7 !== 116) {
                    exit = 2;
                  } else {
                    var match$8 = x$1[1];
                    if (match$8 && match$8[0] === 111) {
                      var match$9 = match$8[1];
                      if (match$9 && match$9[0] === 114) {
                        var match$10 = parse_int(match$9[1]);
                        var match$11 = parse_type_(match$10[1]);
                        var match$12 = parse_exp(match$11[1]);
                        return /* tuple */[
                                /* Ctor */Block.__(11, [
                                    match$10[0],
                                    match$11[0],
                                    match$12[0]
                                  ]),
                                match$12[1]
                              ];
                      }
                      exit = 2;
                    } else {
                      exit = 2;
                    }
                  }
                } else {
                  var match$13 = x$1[1];
                  if (match$13 && match$13[0] === 115) {
                    var match$14 = match$13[1];
                    if (match$14 && match$14[0] === 101) {
                      var match$15 = parse_exp(match$14[1]);
                      var match$16 = parse_branches(match$15[1]);
                      return /* tuple */[
                              /* Case */Block.__(12, [
                                  match$15[0],
                                  match$16[0]
                                ]),
                              match$16[1]
                            ];
                    }
                    exit = 2;
                  } else {
                    exit = 2;
                  }
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                var match$17 = parse_exp(x$1);
                var match$18 = parse_exp(match$17[1]);
                return /* tuple */[
                        /* Cons */Block.__(3, [
                            match$17[0],
                            match$18[0]
                          ]),
                        match$18[1]
                      ];
              }
              break;
          case 102 :
              var match$19 = x[1];
              if (match$19) {
                var match$20 = match$19[0];
                if (match$20 !== 108) {
                  if (match$20 === 115) {
                    var match$21 = match$19[1];
                    if (match$21 && match$21[0] === 116) {
                      var match$22 = parse_exp(match$21[1]);
                      return /* tuple */[
                              /* Fst */Block.__(9, [match$22[0]]),
                              match$22[1]
                            ];
                    }
                    
                  }
                  
                } else {
                  var match$23 = match$19[1];
                  if (match$23 && match$23[0] === 111) {
                    var match$24 = match$23[1];
                    if (match$24 && match$24[0] === 97) {
                      var match$25 = match$24[1];
                      if (match$25 && match$25[0] === 116) {
                        var match$26 = parse_float(match$25[1]);
                        return /* tuple */[
                                /* Float */Block.__(1, [match$26[0]]),
                                match$26[1]
                              ];
                      }
                      
                    }
                    
                  }
                  
                }
              }
              break;
          case 104 :
              var match$27 = parse_int(x[1]);
              return /* tuple */[
                      /* Hole */Block.__(6, [match$27[0]]),
                      match$27[1]
                    ];
          case 105 :
              var match$28 = parse_int(x[1]);
              return /* tuple */[
                      /* Int */Block.__(0, [match$28[0]]),
                      match$28[1]
                    ];
          case 110 :
              return /* tuple */[
                      /* Nil */0,
                      x[1]
                    ];
          case 112 :
              var match$29 = parse_exp(x[1]);
              var match$30 = parse_exp(match$29[1]);
              return /* tuple */[
                      /* Pair */Block.__(8, [
                          match$29[0],
                          match$30[0]
                        ]),
                      match$30[1]
                    ];
          case 115 :
              var match$31 = parse_exp(x[1]);
              return /* tuple */[
                      /* Snd */Block.__(10, [match$31[0]]),
                      match$31[1]
                    ];
          case 33 :
          case 34 :
          case 35 :
          case 36 :
          case 37 :
          case 38 :
          case 39 :
          case 42 :
          case 43 :
          case 46 :
          case 47 :
          case 48 :
          case 49 :
          case 50 :
          case 51 :
          case 52 :
          case 53 :
          case 54 :
          case 55 :
          case 56 :
          case 57 :
          case 58 :
          case 59 :
          case 61 :
          case 63 :
          case 64 :
          case 65 :
          case 66 :
          case 67 :
          case 68 :
          case 69 :
          case 70 :
          case 71 :
          case 72 :
          case 73 :
          case 74 :
          case 75 :
          case 76 :
          case 77 :
          case 78 :
          case 79 :
          case 80 :
          case 81 :
          case 82 :
          case 83 :
          case 84 :
          case 85 :
          case 86 :
          case 87 :
          case 88 :
          case 89 :
          case 90 :
          case 91 :
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 100 :
          case 101 :
          case 103 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 111 :
          case 113 :
          case 114 :
          case 116 :
              break;
          case 117 :
              return /* tuple */[
                      /* Unit */1,
                      x[1]
                    ];
          case 118 :
              var match$32 = parse_int(x[1]);
              return /* tuple */[
                      /* Var */Block.__(7, [match$32[0]]),
                      match$32[1]
                    ];
          default:
            
        }
      } else if (match >= 9) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an exp, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['float', 'ctor', 'case', 'fst', '\\\\', 'i', 'b', 'c', 'n', 'a', 'h', 'u', 'v', 'p', 's']"));
  };
}

function parse_res(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var switcher = x[0] - 9 | 0;
      if (switcher > 23 || switcher < 0) {
        switch (switcher) {
          case 31 :
          case 32 :
          case 35 :
          case 36 :
          case 51 :
          case 53 :
              _x = x[1];
              continue ;
          case 83 :
              var match = parse_int(x[1]);
              var match$1 = parse_type_(match[1]);
              var match$2 = parse_exp(match$1[1]);
              var match$3 = parse_environment(match$2[1]);
              return /* tuple */[
                      /* Rfunc */Block.__(4, [
                          match[0],
                          match$1[0],
                          match$2[0],
                          match$3[0]
                        ]),
                      match$3[1]
                    ];
          case 88 :
              var match$4 = parse_res(x[1]);
              var match$5 = parse_res(match$4[1]);
              return /* tuple */[
                      /* Rapp */Block.__(5, [
                          match$4[0],
                          match$5[0]
                        ]),
                      match$5[1]
                    ];
          case 89 :
              var match$6 = parse_bool(x[1]);
              return /* tuple */[
                      /* Rbool */Block.__(2, [match$6[0]]),
                      match$6[1]
                    ];
          case 90 :
              var x$1 = x[1];
              var exit = 0;
              if (x$1) {
                var match$7 = x$1[0];
                if (match$7 !== 97) {
                  if (match$7 !== 116) {
                    exit = 2;
                  } else {
                    var match$8 = x$1[1];
                    if (match$8 && match$8[0] === 111) {
                      var match$9 = match$8[1];
                      if (match$9 && match$9[0] === 114) {
                        var match$10 = parse_int(match$9[1]);
                        var match$11 = parse_res(match$10[1]);
                        return /* tuple */[
                                /* Rctor */Block.__(10, [
                                    match$10[0],
                                    match$11[0]
                                  ]),
                                match$11[1]
                              ];
                      }
                      exit = 2;
                    } else {
                      exit = 2;
                    }
                  }
                } else {
                  var match$12 = x$1[1];
                  if (match$12 && match$12[0] === 115) {
                    var match$13 = match$12[1];
                    if (match$13 && match$13[0] === 101) {
                      var match$14 = parse_res(match$13[1]);
                      var match$15 = parse_branches(match$14[1]);
                      var match$16 = parse_environment(match$15[1]);
                      return /* tuple */[
                              /* Rcase */Block.__(12, [
                                  match$14[0],
                                  match$15[0],
                                  match$16[0]
                                ]),
                              match$16[1]
                            ];
                    }
                    exit = 2;
                  } else {
                    exit = 2;
                  }
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                var match$17 = parse_res(x$1);
                var match$18 = parse_res(match$17[1]);
                return /* tuple */[
                        /* Rcons */Block.__(3, [
                            match$17[0],
                            match$18[0]
                          ]),
                        match$18[1]
                      ];
              }
              break;
          case 93 :
              var match$19 = x[1];
              if (match$19) {
                var match$20 = match$19[0];
                if (match$20 !== 108) {
                  if (match$20 === 115) {
                    var match$21 = match$19[1];
                    if (match$21 && match$21[0] === 116) {
                      var match$22 = parse_res(match$21[1]);
                      return /* tuple */[
                              /* Rfst */Block.__(8, [match$22[0]]),
                              match$22[1]
                            ];
                    }
                    
                  }
                  
                } else {
                  var match$23 = match$19[1];
                  if (match$23 && match$23[0] === 111) {
                    var match$24 = match$23[1];
                    if (match$24 && match$24[0] === 97) {
                      var match$25 = match$24[1];
                      if (match$25 && match$25[0] === 116) {
                        var match$26 = parse_float(match$25[1]);
                        return /* tuple */[
                                /* Rfloat */Block.__(1, [match$26[0]]),
                                match$26[1]
                              ];
                      }
                      
                    }
                    
                  }
                  
                }
              }
              break;
          case 95 :
              var match$27 = parse_int(x[1]);
              var match$28 = parse_environment(match$27[1]);
              return /* tuple */[
                      /* Rhole */Block.__(6, [
                          match$27[0],
                          match$28[0]
                        ]),
                      match$28[1]
                    ];
          case 96 :
              var x$2 = x[1];
              var exit$1 = 0;
              if (x$2 && x$2[0] === 99) {
                var match$29 = x$2[1];
                if (match$29 && match$29[0] === 116) {
                  var match$30 = match$29[1];
                  if (match$30 && match$30[0] === 111) {
                    var match$31 = match$30[1];
                    if (match$31 && match$31[0] === 114) {
                      var match$32 = parse_int(match$31[1]);
                      var match$33 = parse_res(match$32[1]);
                      return /* tuple */[
                              /* Rictor */Block.__(11, [
                                  match$32[0],
                                  match$33[0]
                                ]),
                              match$33[1]
                            ];
                    }
                    exit$1 = 2;
                  } else {
                    exit$1 = 2;
                  }
                } else {
                  exit$1 = 2;
                }
              } else {
                exit$1 = 2;
              }
              if (exit$1 === 2) {
                var match$34 = parse_int(x$2);
                return /* tuple */[
                        /* Rint */Block.__(0, [match$34[0]]),
                        match$34[1]
                      ];
              }
              break;
          case 101 :
              return /* tuple */[
                      /* Rnil */0,
                      x[1]
                    ];
          case 103 :
              var match$35 = parse_res(x[1]);
              var match$36 = parse_res(match$35[1]);
              return /* tuple */[
                      /* Rpair */Block.__(7, [
                          match$35[0],
                          match$36[0]
                        ]),
                      match$36[1]
                    ];
          case 106 :
              var match$37 = parse_res(x[1]);
              return /* tuple */[
                      /* Rsnd */Block.__(9, [match$37[0]]),
                      match$37[1]
                    ];
          case 33 :
          case 34 :
          case 37 :
          case 38 :
          case 39 :
          case 40 :
          case 41 :
          case 42 :
          case 43 :
          case 44 :
          case 45 :
          case 46 :
          case 47 :
          case 48 :
          case 49 :
          case 50 :
          case 52 :
          case 54 :
          case 55 :
          case 56 :
          case 57 :
          case 58 :
          case 59 :
          case 60 :
          case 61 :
          case 62 :
          case 63 :
          case 64 :
          case 65 :
          case 66 :
          case 67 :
          case 68 :
          case 69 :
          case 70 :
          case 71 :
          case 72 :
          case 73 :
          case 74 :
          case 75 :
          case 76 :
          case 77 :
          case 78 :
          case 79 :
          case 80 :
          case 81 :
          case 82 :
          case 84 :
          case 85 :
          case 86 :
          case 87 :
          case 91 :
          case 92 :
          case 94 :
          case 97 :
          case 98 :
          case 99 :
          case 100 :
          case 102 :
          case 104 :
          case 105 :
          case 107 :
              break;
          case 108 :
              return /* tuple */[
                      /* Runit */1,
                      x[1]
                    ];
          default:
            
        }
      } else if (switcher > 22 || switcher < 2) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an res, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['float', 'ictor', 'ctor', 'case', 'fst', '\\\\', 'i', 'b', 'c', 'n', 'a', 'h', 'u', 'p', 's']"));
  };
}

function parse_debug_construct(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 99 :
              var x$1 = x[1];
              var exit = 0;
              if (x$1 && x$1[0] === 111) {
                var match$1 = x$1[1];
                if (match$1 && match$1[0] === 110) {
                  var match$2 = match$1[1];
                  if (match$2 && match$2[0] === 115) {
                    var match$3 = match$2[1];
                    if (match$3 && match$3[0] === 116) {
                      var match$4 = match$3[1];
                      if (match$4 && match$4[0] === 114) {
                        var match$5 = match$4[1];
                        if (match$5 && match$5[0] === 97) {
                          var match$6 = match$5[1];
                          if (match$6 && match$6[0] === 105) {
                            var match$7 = match$6[1];
                            if (match$7 && match$7[0] === 110) {
                              var match$8 = match$7[1];
                              if (match$8 && match$8[0] === 116) {
                                var match$9 = Pervasives.failwith("parse_constraint_ Not Implemented");
                                return /* tuple */[
                                        /* Constraint_ */Block.__(5, [match$9[0]]),
                                        match$9[1]
                                      ];
                              }
                              exit = 2;
                            } else {
                              exit = 2;
                            }
                          } else {
                            exit = 2;
                          }
                        } else {
                          exit = 2;
                        }
                      } else {
                        exit = 2;
                      }
                    } else {
                      exit = 2;
                    }
                  } else {
                    exit = 2;
                  }
                } else {
                  exit = 2;
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                var match$10 = parse_context(x$1);
                return /* tuple */[
                        /* Context */Block.__(6, [match$10[0]]),
                        match$10[1]
                      ];
              }
              break;
          case 100 :
              var match$11 = parse_int(x[1]);
              return /* tuple */[
                      /* DB_Int */Block.__(8, [match$11[0]]),
                      match$11[1]
                    ];
          case 101 :
              var x$2 = x[1];
              var exit$1 = 0;
              if (x$2) {
                var match$12 = x$2[0];
                if (match$12 !== 110) {
                  if (match$12 !== 120) {
                    exit$1 = 2;
                  } else {
                    var x$3 = x$2[1];
                    var exit$2 = 0;
                    if (x$3 && x$3[0] === 99) {
                      var match$13 = x$3[1];
                      if (match$13 && match$13[0] === 111) {
                        var match$14 = match$13[1];
                        if (match$14 && match$14[0] === 110) {
                          var match$15 = match$14[1];
                          if (match$15 && match$15[0] === 115) {
                            var match$16 = parse_excons(match$15[1]);
                            return /* tuple */[
                                    /* Excons */Block.__(15, [match$16[0]]),
                                    match$16[1]
                                  ];
                          }
                          exit$2 = 3;
                        } else {
                          exit$2 = 3;
                        }
                      } else {
                        exit$2 = 3;
                      }
                    } else {
                      exit$2 = 3;
                    }
                    if (exit$2 === 3) {
                      var match$17 = parse_example(x$3);
                      return /* tuple */[
                              /* Example */Block.__(4, [match$17[0]]),
                              match$17[1]
                            ];
                    }
                    
                  }
                } else {
                  var match$18 = x$2[1];
                  if (match$18 && match$18[0] === 118) {
                    var match$19 = parse_environment(match$18[1]);
                    return /* tuple */[
                            /* Environment */Block.__(1, [match$19[0]]),
                            match$19[1]
                          ];
                  }
                  exit$1 = 2;
                }
              } else {
                exit$1 = 2;
              }
              if (exit$1 === 2) {
                var match$20 = parse_exp(x$2);
                return /* tuple */[
                        /* Exp */Block.__(0, [match$20[0]]),
                        match$20[1]
                      ];
              }
              break;
          case 102 :
              var match$21 = parse_filler_output(x[1]);
              return /* tuple */[
                      /* Filler_Output */Block.__(11, [match$21[0]]),
                      match$21[1]
                    ];
          case 103 :
              var match$22 = Pervasives.failwith("parse_guess_output Not Implemented");
              return /* tuple */[
                      /* Guess_Output */Block.__(9, [match$22[0]]),
                      match$22[1]
                    ];
          case 104 :
              var match$23 = x[1];
              if (match$23) {
                switch (match$23[0]) {
                  case 99 :
                      var match$24 = parse_hole_context(match$23[1]);
                      return /* tuple */[
                              /* Hole_Context */Block.__(7, [match$24[0]]),
                              match$24[1]
                            ];
                  case 102 :
                      var match$25 = parse_hole_fillings(match$23[1]);
                      return /* tuple */[
                              /* Hole_Fillings */Block.__(12, [match$25[0]]),
                              match$25[1]
                            ];
                  case 100 :
                  case 101 :
                  case 103 :
                  case 104 :
                      break;
                  case 105 :
                      var match$26 = parse_int(match$23[1]);
                      return /* tuple */[
                              /* Hole_Identifier */Block.__(14, [match$26[0]]),
                              match$26[1]
                            ];
                  default:
                    
                }
              }
              break;
          case 105 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 112 :
          case 113 :
              break;
          case 114 :
              var match$27 = parse_res(x[1]);
              return /* tuple */[
                      /* Res */Block.__(2, [match$27[0]]),
                      match$27[1]
                    ];
          case 115 :
              var match$28 = parse_solver_output(x[1]);
              return /* tuple */[
                      /* Solver_Output */Block.__(10, [match$28[0]]),
                      match$28[1]
                    ];
          case 116 :
              var match$29 = parse_type_(x[1]);
              return /* tuple */[
                      /* Type_ */Block.__(3, [match$29[0]]),
                      match$29[1]
                    ];
          case 117 :
              var x$4 = x[1];
              var exit$3 = 0;
              if (x$4 && x$4[0] === 110) {
                var match$30 = x$4[1];
                if (match$30 && match$30[0] === 101) {
                  var match$31 = match$30[1];
                  if (match$31 && match$31[0] === 118) {
                    var match$32 = match$31[1];
                    if (match$32 && match$32[0] === 97) {
                      var match$33 = match$32[1];
                      if (match$33 && match$33[0] === 108) {
                        var match$34 = match$33[1];
                        if (match$34 && match$34[0] === 99) {
                          var match$35 = match$34[1];
                          if (match$35 && match$35[0] === 111) {
                            var match$36 = match$35[1];
                            if (match$36 && match$36[0] === 110) {
                              var match$37 = match$36[1];
                              if (match$37 && match$37[0] === 115) {
                                var match$38 = parse_unevalcons(match$37[1]);
                                return /* tuple */[
                                        /* Unevalcons */Block.__(16, [match$38[0]]),
                                        match$38[1]
                                      ];
                              }
                              exit$3 = 2;
                            } else {
                              exit$3 = 2;
                            }
                          } else {
                            exit$3 = 2;
                          }
                        } else {
                          exit$3 = 2;
                        }
                      } else {
                        exit$3 = 2;
                      }
                    } else {
                      exit$3 = 2;
                    }
                  } else {
                    exit$3 = 2;
                  }
                } else {
                  exit$3 = 2;
                }
              } else {
                exit$3 = 2;
              }
              if (exit$3 === 2) {
                var match$39 = parse_unfilled_holes(x$4);
                return /* tuple */[
                        /* Unfilled_Holes */Block.__(13, [match$39[0]]),
                        match$39[1]
                      ];
              }
              break;
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an debug_construct, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['constraint', 'unevalcons', 'excons', 'env', 'ex', 'hc', 'hf', 'hi', 'e', 'r', 't', 'c', 'd', 'g', 's', 'f', 'u']"));
  };
}

function parse_solver_output(x) {
  parse_token(x);
  return Pervasives.failwith("solver_output_of_string Not Implemented");
}

function parse_float(x) {
  var match = parse_token(x);
  return /* tuple */[
          Caml_format.caml_float_of_string(match[0]),
          match[1]
        ];
}

function parse_branches(x) {
  parse_token(x);
  return Pervasives.failwith("branches_of_string Not Implemented");
}

function parse_bool(x) {
  var match = parse_token(x);
  return /* tuple */[
          Pervasives.bool_of_string(match[0]),
          match[1]
        ];
}

function parse_value(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 98 :
              var match$1 = parse_bool(x[1]);
              return /* tuple */[
                      /* Vbool */Block.__(1, [match$1[0]]),
                      match$1[1]
                    ];
          case 99 :
              var match$2 = parse_int(x[1]);
              var match$3 = parse_value(match$2[1]);
              return /* tuple */[
                      /* Vctor */Block.__(3, [
                          match$2[0],
                          match$3[0]
                        ]),
                      match$3[1]
                    ];
          case 105 :
              var match$4 = parse_int(x[1]);
              return /* tuple */[
                      /* Vint */Block.__(0, [match$4[0]]),
                      match$4[1]
                    ];
          case 112 :
              var match$5 = parse_value(x[1]);
              var match$6 = parse_value(match$5[1]);
              return /* tuple */[
                      /* Vpair */Block.__(2, [
                          match$5[0],
                          match$6[0]
                        ]),
                      match$6[1]
                    ];
          case 100 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
              break;
          case 117 :
              return /* tuple */[
                      /* Vunit */0,
                      x[1]
                    ];
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an value, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['i', 'b', 'u', 'p', 'c']"));
  };
}

function parse_adt(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 108 :
              return /* tuple */[
                      /* List */0,
                      x[1]
                    ];
          case 109 :
              break;
          case 110 :
              return /* tuple */[
                      /* Num */1,
                      x[1]
                    ];
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an adt, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['l', 'n']"));
  };
}

function parse_constraint_(param) {
  return Pervasives.failwith("parse_constraint_ Not Implemented");
}

function parse_guess_output(param) {
  return Pervasives.failwith("parse_guess_output Not Implemented");
}

exports.make_list = make_list;
exports.explode = explode;
exports.implode = implode;
exports.parse_token = parse_token;
exports.parse_exp = parse_exp;
exports.parse_res = parse_res;
exports.parse_type_ = parse_type_;
exports.parse_adt = parse_adt;
exports.parse_example = parse_example;
exports.parse_value = parse_value;
exports.parse_debug_construct = parse_debug_construct;
exports.parse_excons = parse_excons;
exports.parse_int = parse_int;
exports.parse_solver_output = parse_solver_output;
exports.parse_unevalcons = parse_unevalcons;
exports.parse_filler_output = parse_filler_output;
exports.parse_unfilled_holes = parse_unfilled_holes;
exports.parse_bool = parse_bool;
exports.parse_environment = parse_environment;
exports.parse_hole_context = parse_hole_context;
exports.parse_float = parse_float;
exports.parse_branches = parse_branches;
exports.parse_hole_fillings = parse_hole_fillings;
exports.parse_constraint_ = parse_constraint_;
exports.parse_guess_output = parse_guess_output;
exports.parse_context = parse_context;
/* No side effect */
