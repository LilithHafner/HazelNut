// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function type_intersection(t1, t2) {
  if (typeof t1 === "number" && t1 === 2) {
    return t2;
  }
  if (typeof t2 === "number") {
    if (t2 !== 2 && !Caml_obj.caml_equal(t1, t2)) {
      return /* Fail_t */3;
    } else {
      return t1;
    }
  } else if (Caml_obj.caml_equal(t1, t2)) {
    return t1;
  } else {
    return /* Fail_t */3;
  }
}

function example_refined_type_intersection(ert1, ert2) {
  return /* tuple */[
          type_intersection(ert1[0], ert2[0]),
          List.append(ert1[1], ert2[1])
        ];
}

function bidirectional_typecheck(ert_exp, environment) {
  var exp_but_with_ERTs_propigated_all_the_way_down_and_almost_all_the_way_back_up = recurse(ert_exp[1], environment);
  var new_ERT = example_refined_type_intersection(ert_exp[0], /* tuple */[
        /* Any_t */2,
        /* [] */0
      ]);
  return /* tuple */[
          new_ERT,
          exp_but_with_ERTs_propigated_all_the_way_down_and_almost_all_the_way_back_up
        ];
}

function recurse(exp, environment) {
  if (typeof exp === "number") {
    return /* Nil */0;
  }
  switch (exp.tag | 0) {
    case /* Int */0 :
        return /* Int */Block.__(0, [exp[0]]);
    case /* Float */1 :
        return /* Float */Block.__(1, [exp[0]]);
    case /* Bool */2 :
        return /* Bool */Block.__(2, [exp[0]]);
    case /* Cons */3 :
        return /* Cons */Block.__(3, [
                  bidirectional_typecheck(exp[0], environment),
                  bidirectional_typecheck(exp[1], environment)
                ]);
    case /* Variable */4 :
        return /* Variable */Block.__(4, [exp[0]]);
    case /* Function */5 :
        return /* Function */Block.__(5, [
                  exp[0],
                  bidirectional_typecheck(exp[1], environment)
                ]);
    case /* Application */6 :
        return /* Application */Block.__(6, [
                  bidirectional_typecheck(exp[0], environment),
                  bidirectional_typecheck(exp[1], environment)
                ]);
    case /* Hole */7 :
        return /* Hole */Block.__(7, [exp[0]]);
    
  }
}

function propigate_ERTs_down_one_level(toplevel_ERT, exp, environment) {
  return exp;
}

function propigate_ERTs_up_one_level(exp) {
  return /* tuple */[
          /* Any_t */2,
          /* [] */0
        ];
}

function refine(specification, environment) {
  var match = specification[0];
  if (typeof match !== "number") {
    return /* [] */0;
  }
  if (match !== 0) {
    return /* [] */0;
  }
  var match$1 = specification[1];
  if (!match$1) {
    return /* [] */0;
  }
  var match$2 = match$1[0];
  var match$3 = match$2[1];
  if (typeof match$3 === "number" || match$3.tag || match$3[0] !== 1 || match$1[1] || !Caml_obj.caml_equal(match$2[0], environment)) {
    return /* [] */0;
  } else {
    return /* :: */[
            /* tuple */[
              /* tuple */[
                /* Int_t */0,
                /* [] */0
              ],
              /* Int */Block.__(0, [1])
            ],
            /* [] */0
          ];
  }
}

function synthesize(sketch) {
  return sketch;
}

function add(x, y) {
  return x + y | 0;
}

Pervasives.print_int(11);

Pervasives.print_string("\n");

var merge_examples = List.append;

exports.type_intersection = type_intersection;
exports.merge_examples = merge_examples;
exports.example_refined_type_intersection = example_refined_type_intersection;
exports.bidirectional_typecheck = bidirectional_typecheck;
exports.propigate_ERTs_down_one_level = propigate_ERTs_down_one_level;
exports.recurse = recurse;
exports.propigate_ERTs_up_one_level = propigate_ERTs_up_one_level;
exports.refine = refine;
exports.synthesize = synthesize;
exports.add = add;
/*  Not a pure module */
