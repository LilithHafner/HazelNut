// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Tools$MyNewProject = require("./Tools.bs.js");
var Types$MyNewProject = require("./Types.bs.js");
var Guesser$MyNewProject = require("./Guesser.bs.js");
var Evaluator$MyNewProject = require("./evaluator.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var IdGenerator$MyNewProject = require("./IdGenerator.bs.js");
var Unevaluator$MyNewProject = require("./unevaluator.bs.js");

function simplifyConstructor(res) {
  if (typeof res === "number") {
    return res;
  }
  if (res.tag !== /* Rictor */11) {
    return res;
  }
  var match = res[1];
  if (typeof match === "number" || !(match.tag === /* Rctor */10 && res[0] === match[0])) {
    return res;
  } else {
    return match[1];
  }
}

function branch_indiv(delta, gamma, typ, exs, datatype) {
  var e = List.hd(Guesser$MyNewProject.guess(delta, gamma, /* D */Block.__(3, [datatype]), 1));
  var constructors = Tools$MyNewProject.lookup(datatype, Types$MyNewProject.sigma);
  var results = List.map((function (param) {
          return Evaluator$MyNewProject.$$eval(param[0], e);
        }), exs);
  var unevalExs = List.concat(List.map((function (param) {
              var env = param[0];
              return List.map((function (param) {
                            return /* tuple */[
                                    env,
                                    /* Ector */Block.__(4, [
                                        param[0],
                                        /* Top */0
                                      ])
                                  ];
                          }), constructors);
            }), exs));
  var unevalCons = Unevaluator$MyNewProject.constrainExp(e, unevalExs);
  var branches = List.map((function (param) {
          var x = IdGenerator$MyNewProject.getId(undefined);
          var h = IdGenerator$MyNewProject.getId(undefined);
          return /* tuple */[
                  param[0],
                  /* tuple */[
                    x,
                    /* Hole */Block.__(6, [h])
                  ]
                ];
        }), constructors);
  var exp = /* Case */Block.__(12, [
      e,
      branches
    ]);
  var newExCons = List.map((function (param) {
          var $$var = param[1][0];
          var id = param[0];
          return List.mapi((function (j, param) {
                        var r = List.nth(results, j);
                        return /* tuple */[
                                /* :: */[
                                  /* tuple */[
                                    $$var,
                                    simplifyConstructor(/* Rictor */Block.__(11, [
                                            id,
                                            r
                                          ]))
                                  ],
                                  param[0]
                                ],
                                param[1]
                              ];
                      }), exs);
        }), branches);
  var goals = List.mapi((function (i, param) {
          var match = param[1];
          var h = match[1];
          if (typeof h === "number") {
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "Brancher.re",
                    65,
                    12
                  ]
                ];
          }
          if (h.tag === /* Hole */6) {
            var match$1 = List.nth(constructors, i);
            var xs = List.nth(newExCons, i);
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        match[0],
                        match$1[1]
                      ],
                      gamma
                    ],
                    h[0],
                    typ,
                    xs
                  ];
          }
          throw [
                Caml_builtin_exceptions.match_failure,
                /* tuple */[
                  "Brancher.re",
                  65,
                  12
                ]
              ];
        }), branches);
  return /* tuple */[
          exp,
          goals,
          unevalCons
        ];
}

function branch(delta, gamma, typ, exs) {
  var datatypes = List.sort_uniq((function (t1, t2) {
          return 0;
        }), List.map((function (t) {
              if (typeof t === "number" || t.tag !== /* D */3) {
                return Pervasives.failwith("Error in branch");
              } else {
                return t[0];
              }
            }), List.filter((function (t) {
                    if (typeof t === "number" || t.tag !== /* D */3) {
                      return false;
                    } else {
                      return true;
                    }
                  }))(List.map((function (param) {
                      return param[1];
                    }), gamma))));
  return List.map((function (d) {
                return branch_indiv(delta, gamma, typ, exs, d);
              }), datatypes);
}

exports.simplifyConstructor = simplifyConstructor;
exports.branch = branch;
exports.branch_indiv = branch_indiv;
/* No side effect */
