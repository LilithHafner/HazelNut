def p(_quit=''):
    out = []
    while True:
        out.append(input())
        if out[-1] == _quit:
            break
    return '\n'.join(out)

def or_of_chars(chars):
    return "'"+"' | '".join(chars)+"'"
whitespace = or_of_chars(['\\t','\\n']+list(' ,()<->'))
blank_of_string_doesnt_work_and_were_okay_with_that = \
    ['filler_output', 'solver_output']#And many more!
lists = [
    ('context', '1234567890', ['int', 'type_', 'ann'], '(v0, (v1, v2))'),
    ('branches', '1234567890', ['int', 'pattern', 'exp'], '(v0, (v1, v2))'),
]

#print(whitespace)
#"' ' | '\\t' | '\\n' | ',' | '(' | ')'"


#{'exp':[('h', 'Hole', ['int']), ('var', 'Variable', ['int'])]}
def build(types):
    out = ['''open Types;
//This is because I couldn't find List.make or List.create
let make_list (n:int, f:int=>'a):list('a) = {
    let out = ref([]);
    for (i in n-1 downto 0) {
        out := [f(i), ...out^]
    }
    out^
}
let explode(str:string):list(char) = 
//This is because I couldn't find String.to_seq
//    str |> String.to_seq |> List.of_seq 
    make_list(String.length(str), String.get(str))
let implode(cs:list(char)):string = 
//Because runtime doesn't matter
    String.init(List.length(cs), List.nth(cs))
let rec skip_whitespace(cs) =
    switch(cs) {
        | ['\t' | '\n' | ' ' | ',' | '(' | ')' | '<' | '-' | '>', ...cs] => skip_whitespace(cs)
        | _ => cs
    }
let rec parse_token(x) = {
    let rec parse_token_r(x, y) = {
        switch(x) {
        | ['0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '.', ..._] => 
            parse_token_r(List.tl(x), [List.hd(x),...y])
        | _ => (x,y)
        };
    }
    let (x,y) = parse_token_r(skip_whitespace(x),[]);
    (implode(List.rev(y)), x)
}''']
    needed_parsers = set()
    for t in types:
        entry = types[t]
        join = "\n    | ["
        constructors = [("{0:}(x) = \n    switch(x) {{\n    | ["+whitespace+", ...x] =>\n        parse_{0:}(x)").format(t)]
        footer = '\n    | _ => failwith("Some code generated by parser_generator.py is throwing a parse error:\\nWhile parsing a/an {}, I got \\"" ++ implode(x) ++ "\\" which doesn\'t match any of the expected tags: {}")\n    }}'.format(t, [c[0] for c in entry])
        for key, name, parameters in entry:
            terms = [", ".join(("'"+c+"'" for c in key) if key[0] != '\\' else ["'"+key+"'"]) + ", ...x] =>"]
            for i,p in enumerate(parameters):
                terms.append('let (v{}, x) = parse_{}(x);'.format(i,p))
                needed_parsers.add(p)
            terms.append("({}{}, x)".format(name, "("+", ".join("v{}".format(i) for i in range(len(parameters)))+")" if parameters else ""))
            constructors.append('\n        '.join(terms))
        out.append(join.join(constructors)+footer)
    for t in needed_parsers:
        if t not in types:
            out.append('{}(x) = {{\n    let(v0, x) = parse_token(x);\n    ({}_of_string(v0), x)\n}}'.format(t,t))

    return '\nand parse_'.join(out)+'\n'

#print(build({'exp':[('h', 'Hole', ['int']), ('var', 'Variable', ['int'])]}))



source = []
marker = '//marker for parser_generator.py'
for line in open('Types.re', 'r'):
    source.append(line)
    if line[:len(marker)] == marker:
        break
else:
    source = []
    print('Warning: No Marker')
source = '\n'.join(source)


def process(source):
    type_names = {}
    for line in source.split('\n'):
        if '//parser_generator.py: ignore' in line:
            continue
        line = line.strip()
        if line[:5] != 'type ' and line[:4] != 'and ':
            continue
        lst = line.split('=')
        if len(lst) != 2 or not lst[-1]:
            continue
        a, b = lst
        a, b = a.strip(), b.strip()#b.replace('.','_').split('(')[0].strip()
        a = a.split()
        if len(a) != 2:
            continue
        a = a[1]
        type_names[a] = b

    current_type = None
    members = {}
    for line in source.split('\n'):
        if '//parser_generator.py: ignore' in line:
            continue
        if line.strip() and line.strip()[-1] == '=':
            current_type = line.strip()[:-1].split()[-1]
            if current_type in members:
                raise ValueError()
            members[current_type] = []
        elif line.strip() and line.strip()[0] == '|':
            if '(' in line:
                try:
                    name, rest = line.strip()[1:].strip().split('(')
                except:
                    print(line)
                    raise
                parameters = rest.split(')')[0].split(', ')
                for i in range(len(parameters)):
                    while parameters[i] in type_names:
                        parameters[i] = type_names[parameters[i]]
            else:
                name, parameters = line.strip()[1:].strip(), []
            members[current_type] += [(name[1 if (current_type in ['res','value'] or current_type == 'example' and name != 'Top') else 0].lower(), name, parameters)]

    return members

post_replacements = [
    ('and parse_environment(x) = {\n    let(v0, x) = parse_token(x);\n    (environment_of_string(v0), x)\n}',
     "and parse_environment(x) = {\n    switch(x) {\n    | ["+whitespace+", ...x] =>\n        parse_environment(x)\n    | ['0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9', ..._] =>   \n        let (v0, x) = parse_int(x);\n        let (v1, x) = parse_res(x);\n        let (v2, x) = parse_environment(x);\n        ([(v0, v1), ...v2], x)\n    | x => ([], x)\n    }\n}"),

#    ("    | ['f', ...x] =>\n        let (v0, x) = parse_type_(x);\n        let (v1, x) = parse_type_(x);\n        (Function_t(v0, v1), x)\n",
#     "    | ['\\\\', ...x] =>\n        let (v0, x) = parse_type_(x);\n        let (v1, x) = parse_type_(x);\n        (Function_t(v0, v1), x)\n"),

#    ("    | ['f', ...x] =>\n        let (v0, x) = parse_int(x);\n        let (v1, x) = parse_exp(x);\n        let (v2, x) = parse_environment(x);\n        (Rfunc(v0, v1, v2), x)\n",
#     "    | ['\\\\', ...x] =>\n        let (v0, x) = parse_int(x);\n        let (v1, x) = parse_exp(x);\n        let (v2, x) = parse_environment(x);\n        (Rfunc(v0, v1, v2), x)\n"),

#    ("    | ['v','a','r', ...x] =>\n        let (v0, x) = parse_int(x);\n        (Var(v0), x)\n",
#     ""),
    
#    ("    | ['v', ...x] =>\n        let (v0, x) = parse_int(x);\n        (Variable(v0), x)\n",
#     "    | ['v','a','r', ...x] =>\n        let (v0, x) = parse_int(x);\n        (Var(v0), x)\n    | ['v', ...x] =>\n        let (v0, x) = parse_int(x);\n        (Variable(v0), x)\n"),

#    ("    | ['e', ...x] =>\n        let (v0, x) = parse_exp(x);\n        (Exp(v0), x)\n    | ['e', ...x] =>\n        let (v0, x) = parse_environment(x);\n        (Environemnt(v0), x)\n",
#     "    | ['e','n','v', ...x] =>\n        let (v0, x) = parse_environment(x);\n        (Environemnt(v0), x)\n    | ['e', ...x] =>\n        let (v0, x) = parse_exp(x);\n        (Exp(v0), x)\n")

    ('''and parse_constraint_(x) = {
    let(v0, x) = parse_token(x);
    (constraint__of_string(v0), x)
}''',
     '''and parse_constraint_(_) = {
    failwith("parse_constraint_ Not Implemented")
}'''),
    ('''and parse_guess_output(x) = {
    let(v0, x) = parse_token(x);
    (guess_output_of_string(v0), x)
}''',
     '''and parse_guess_output(_) = {
    failwith("parse_guess_output Not Implemented")
}'''),
##    ('''and parse_context(x) = {
##    let(v0, x) = parse_token(x);
##    (context_of_string(v0), x)
##}''',
##     '''and parse_context(x) = {
##    switch(x) {
##    | ['''+whitespace+''', ...x] =>
##        parse_context(x)
##    | ['0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9', ..._] =>   
##        let (v0, x) = parse_int(x);
##        let (v1, x) = parse_type_(x);
##        let (v2, x) = parse_context(x);
##        ([(v0, v1), ...v2], x)
##    | x => ([], x)
##    }
##}'''),
    ('''and parse_hole_context(x) = {
    let(v0, x) = parse_token(x);
    (hole_context_of_string(v0), x)
}''',
     '''and parse_hole_context(x) = {
    switch(x) {
    | ['''+whitespace+''', ...x] =>
        parse_hole_context(x)
    | ['0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9', ..._] =>   
        let (v0, x) = parse_int(x);
        let (v1, x) = parse_context(x);
        let (v2, x) = parse_type_(x);
        let (v3, x) = parse_hole_context(x);
        ([(v0, (v1, v2)), ...v3], x)
    | x => ([], x)
    }
}'''),

    ('    | x => ([], x)','    | [\';\', ...x] | x => ([], x)'),
    ('''(excons_of_string(v0), x)''','''failwith("excons_of_string Not Implemented")'''),
    ('''(unevalcons_of_string(v0), x)''','''failwith("unevalcons_of_string Not Implemented")'''),
    ('''(unfilled_holes_of_string(v0), x)''','''failwith("unfilled_holes_of_string Not Implemented")'''),
    ('''(hole_fillings_of_string(v0), x)''','''failwith("hole_fillings_of_string Not Implemented")'''),
] + [
        ('''({}_of_string(v0), x)'''.format(x),'''failwith("{}_of_string Not Implemented")'''.format(x)) for x in
        blank_of_string_doesnt_work_and_were_okay_with_that
] + [
    ('''and parse_{name}(x) = {{
    let(v0, x) = parse_token(x);
    ({name}_of_string(v0), x)
}}'''.format(name=name),
     '''and parse_{name}(x) = {{
    switch(x) {{
    | [{whitespace}, ...x] =>
        parse_{name}(x)
    | [{chars}, ..._] =>   
        {declarations}
        let (rest, x) = parse_{name}(x);
        ([{constructor}, ...rest], x)
    | x => ([], x)
    }}
}}'''.format(name=name,whitespace=whitespace,constructor=constructor,chars=or_of_chars(chars),declarations=
    '\n'.join(' '*8+'let (v{i}, x) = parse_{t}(x);'.format(i=i,t=t) for i,t in enumerate(types))))

    for name, chars, types, constructor in lists
]
def post_process(out):
    for a,b in post_replacements:
        out = out.replace(a,b)
    return out
mid_replacements = {
('f','Rfst',('res',)):('fst','Rfst',('res',)),
('f','Fst',('exp',)):('fst','Fst',('exp',)),
#('v','Var',('int',)):('var','Var',('int',)),
('e','Environment',('environment',)):('env','Environment',('environment',)),
('f','Function',('int','type_','exp')):('\\\\','Function',('int', 'type_','exp')),
('f','Rfunc',('int','type_','exp', 'environment')):('\\\\','Rfunc',('int', 'type_','exp', 'environment')),
#('f','Efunc',('int','exp', 'environment')):('\\\\','Efunc',('int','exp', 'environment')),
('f','Fail_t',()):('fail','Fail_t',()),
('f','Float',('float',)):('float','Float',('float',)),
('f','Rfloat',('float',)):('float','Rfloat',('float',)),
('e','Example',('example',)):('ex','Example',('example',)),
    }
def mid_process(specs):
    for key in specs:
        for i,(a,b,c) in enumerate(specs[key]):
            if (a,b,tuple(c)) in mid_replacements:
                a2,b2,c2 = mid_replacements[(a,b,tuple(c))]
                del mid_replacements[(a,b,tuple(c))]
                specs[key][i] = [a2,b2,list(c2)]
            else:
                specs[key][i] = [a,b,list(c)]
                
        
    if mid_replacements:
        print(mid_replacements)
    sort_spec(specs)
    return specs

def sort_spec(spec):
    for key in spec:
        spec[key].sort(key=lambda x:len(x[0]), reverse=True)

def pipeline(string):
    global pspec
    pspec = process(string)
    mid_process(pspec)
    resolve_conflicts(pspec)
    return post_process(build(pspec))

def f():
    print(pipeline(p("QUIT")))

#spec = {'exp': [('i', 'Int', ['int']), ('f', 'Float', ['float']), ('b', 'Bool', ['bool']), ('c', 'Cons', ['exp', 'exp']), ('n', 'Nil', []), ('v', 'Variable', ['int']), ('f', 'Function', ['int', 'exp']), ('a', 'Application', ['exp', 'exp']), ('h', 'Hole', ['int']), ('u', 'Unit', []), ('v', 'Var', ['int']), ('p', 'Pair', ['exp', 'exp']), ('f', 'Fst', ['exp']), ('s', 'Snd', ['exp'])], 'res': [('i', 'Rint', ['int']), ('f', 'Rfloat', ['float']), ('b', 'Rbool', ['bool']), ('c', 'Rcons', ['res', 'res']), ('n', 'Rnil', []), ('f', 'Rfunc', ['int', 'exp', 'environment']), ('a', 'Rapp', ['res', 'res']), ('h', 'Rhole', ['int', 'environment']), ('u', 'Runit', []), ('p', 'Rpair', ['res', 'res']), ('f', 'Rfst', ['res']), ('s', 'Rsnd', ['res'])], 'type_': [('i', 'Int_t', []), ('b', 'Bool_t', []), ('c', 'Cons_t', ['type_']), ('f', 'Function_t', ['type_', 'type_']), ('u', 'Unit_t', []), ('p', 'Pair_t', ['type_', 'type_']), ('a', 'Any_t', []), ('f', 'Fail_t', [])], 'debug_construct': [('e', 'Exp', ['exp']), ('e', 'Environemnt', ['environment']), ('r', 'Res', ['res'])]}

def save(out):
    open('Parser.re','w').write(out)



    


def pconflicts(spec):
    out = []
    for typ in spec:
        out.append('\n' + str(typ) + '\n' + '='*20)
        constructors = spec[typ]
        dct = {}
        for a,b,c in constructors:
            if a in dct:
                out.append(str(a)+ ', '+ str(dct[a][0]) + ', ' + str(dct[a][1]) + ' | ' + str(a)+ ', ' +str(b) + ', ' + str(c))
            else:
                dct[a] = b,c
    print('\n'.join(out))
def pres():
    out = []
    for r in conflict_resolutions:
        out.append(' -> '.join(r))
    print('\n'.join(out))

def find_in_pspec(name):
    for typ in pspec:
        for constructor in pspec[typ]:
            if constructor[1] == name:
                return [typ,] + constructor

def print_resolution(resolution):
    print(str(find_in_pspec(resolution[0])) + ' -> ' + str(resolution[1]))

conflict_resolutions = [['Case', 'case'], ['Ctor', 'ctor'], ['Rcase', 'case'], ['Rictor', 'ictor'], ['Rctor', 'ctor'], ['Hole_Context', 'hc'], ['Hole_Fillings', 'hf'], ['Hole_Identifier', 'hi'], ['Excons', 'excons'], ['Unevalcons', 'unevalcons'], ['Constraint_', 'constraint']]

def resolve_conflicts(spec):
    for c in conflict_resolutions:
        for typ in spec:
            for constructor in spec[typ]:
                if constructor[1] == c[0]:
                    constructor[0] = c[1]
    sort_spec(spec)
        

def resolve():
    pconflicts(pspec)
    while True:
        inp = input()
        if inp in ['', 'q']:
            print_resolutions()
            break
        elif inp in ['-', 'u', 'z', 'undo']:
            print_resolution(conflict_resolutions.pop())
        elif inp in ['p', 'print']:
            pres()
        else:
            inp = inp.split()
            if len(inp) != 2:
                print('arity problem')
                continue
            if find_in_pspec(inp[0]) is None:
                print('Sorry bud, can\'t find that constructor.')
                continue
            conflict_resolutions.append(inp)
            print_resolution(conflict_resolutions[-1])
def print_resolutions():
    print('conflict_resolutions = '+repr(conflict_resolutions))

if __name__ == '__main__':
    #print(pipeline(source))
    save(pipeline(source))
