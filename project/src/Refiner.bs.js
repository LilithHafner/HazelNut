// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Tools$MyNewProject = require("./Tools.bs.js");
var Types$MyNewProject = require("./Types.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var IdGenerator$MyNewProject = require("./IdGenerator.bs.js");

var outFunc = {
  contents: true
};

function refinable(typ, exs) {
  if (typeof typ === "number") {
    if (typ === /* Unit_t */2) {
      return true;
    } else {
      return false;
    }
  }
  switch (typ.tag | 0) {
    case /* Function_t */1 :
    case /* Pair_t */2 :
        return true;
    case /* D */3 :
        if (!exs) {
          return true;
        }
        var match = exs[0][1];
        if (typeof match === "number") {
          return false;
        }
        if (match.tag !== /* Ector */4) {
          return false;
        }
        var xs = exs[1];
        var id = match[0];
        return List.length(List.filter((function (param) {
                            var match = param[1];
                            if (typeof match === "number") {
                              throw [
                                    Caml_builtin_exceptions.match_failure,
                                    /* tuple */[
                                      "Refiner.re",
                                      16,
                                      44
                                    ]
                                  ];
                            }
                            if (match.tag === /* Ector */4) {
                              return id === match[0];
                            }
                            throw [
                                  Caml_builtin_exceptions.match_failure,
                                  /* tuple */[
                                    "Refiner.re",
                                    16,
                                    44
                                  ]
                                ];
                          }))(xs)) === List.length(xs);
    default:
      return false;
  }
}

function allUnit(_exs) {
  while(true) {
    var exs = _exs;
    if (!exs) {
      return true;
    }
    var match = exs[0][1];
    if (typeof match !== "number") {
      return false;
    }
    if (match === 0) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allPairs(_exs) {
  while(true) {
    var exs = _exs;
    if (!exs) {
      return true;
    }
    var tmp = exs[0][1];
    if (typeof tmp === "number") {
      return false;
    }
    if (tmp.tag !== /* Epair */2) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allFuncs(_exs) {
  while(true) {
    var exs = _exs;
    if (!exs) {
      return true;
    }
    var tmp = exs[0][1];
    if (typeof tmp === "number") {
      return false;
    }
    if (tmp.tag !== /* Efunc */3) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allConstructs(exs) {
  var c;
  if (exs) {
    var match = exs[0][1];
    c = typeof match === "number" || match.tag !== /* Ector */4 ? undefined : match[0];
  } else {
    c = undefined;
  }
  if (c === undefined) {
    return ;
  }
  var haveIdC = List.filter((function (param) {
            var tmp = param[1];
            if (typeof tmp === "number" || tmp.tag !== /* Ector */4) {
              return false;
            } else {
              return true;
            }
          }))(exs);
  if (List.length(haveIdC) === List.length(exs)) {
    return c;
  }
  
}

function firstExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          74,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Epair */2) {
                  return /* tuple */[
                          param[0],
                          match[0]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        74,
                        4
                      ]
                    ];
              }), exs);
}

function sndExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          78,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Epair */2) {
                  return /* tuple */[
                          param[0],
                          match[1]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        78,
                        4
                      ]
                    ];
              }), exs);
}

function prepFuncExs(exs, e) {
  if (typeof e === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Refiner.re",
            82,
            8
          ]
        ];
  }
  if (e.tag === /* Function */4) {
    var e$prime = e[3];
    var t = e[2];
    var x = e[1];
    var n = e[0];
    return List.map((function (param) {
                  var match = param[1];
                  if (typeof match === "number") {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          /* tuple */[
                            "Refiner.re",
                            84,
                            4
                          ]
                        ];
                  }
                  if (match.tag === /* Efunc */3) {
                    var env = param[0];
                    return /* tuple */[
                            /* :: */[
                              /* tuple */[
                                n,
                                /* Rfunc */Block.__(4, [
                                    n,
                                    x,
                                    t,
                                    e$prime,
                                    env
                                  ])
                              ],
                              /* :: */[
                                /* tuple */[
                                  x,
                                  Types$MyNewProject.valToRes(match[0])
                                ],
                                env
                              ]
                            ],
                            match[1]
                          ];
                  }
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          84,
                          4
                        ]
                      ];
                }), exs);
  }
  throw [
        Caml_builtin_exceptions.match_failure,
        /* tuple */[
          "Refiner.re",
          82,
          8
        ]
      ];
}

function prepConsExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          89,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Ector */4) {
                  return /* tuple */[
                          param[0],
                          match[2]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        89,
                        4
                      ]
                    ];
              }), exs);
}

function refine(context, typ, exs) {
  if (typeof typ === "number") {
    if (typ === /* Unit_t */2) {
      if (allUnit(exs)) {
        return /* tuple */[
                /* Unit */1,
                /* [] */0
              ];
      } else {
        return Pervasives.failwith("Goal type inconsistent with examples");
      }
    } else {
      return Pervasives.failwith("Not a refinement type");
    }
  }
  switch (typ.tag | 0) {
    case /* Function_t */1 :
        var t2 = typ[1];
        var t1 = typ[0];
        if (!allFuncs(exs)) {
          return Pervasives.failwith("Goal type inconsistent with examples");
        }
        var n = IdGenerator$MyNewProject.getId(undefined);
        var x = IdGenerator$MyNewProject.getId(undefined);
        var h = IdGenerator$MyNewProject.getId(undefined);
        var e_003 = /* Hole */Block.__(6, [h]);
        var e = /* Function */Block.__(4, [
            n,
            x,
            t1,
            e_003
          ]);
        if (outFunc.contents) {
          outFunc.contents = false;
          return /* tuple */[
                  e,
                  /* :: */[
                    /* tuple */[
                      /* :: */[
                        /* tuple */[
                          n,
                          /* tuple */[
                            /* Function_t */Block.__(1, [
                                t1,
                                t2
                              ]),
                            /* AnnFunc */3
                          ]
                        ],
                        /* :: */[
                          /* tuple */[
                            x,
                            /* tuple */[
                              t1,
                              /* AnnArg */1
                            ]
                          ],
                          context
                        ]
                      ],
                      h,
                      t2,
                      prepFuncExs(exs, e)
                    ],
                    /* [] */0
                  ]
                ];
        } else {
          return /* tuple */[
                  e,
                  /* :: */[
                    /* tuple */[
                      /* :: */[
                        /* tuple */[
                          x,
                          /* tuple */[
                            t1,
                            /* AnnArg */1
                          ]
                        ],
                        context
                      ],
                      h,
                      t2,
                      prepFuncExs(exs, e)
                    ],
                    /* [] */0
                  ]
                ];
        }
    case /* Pair_t */2 :
        if (!allPairs(exs)) {
          return Pervasives.failwith("Goal type inconsistent with examples");
        }
        var x$1 = IdGenerator$MyNewProject.getId(undefined);
        var y = IdGenerator$MyNewProject.getId(undefined);
        return /* tuple */[
                /* Pair */Block.__(8, [
                    /* Hole */Block.__(6, [x$1]),
                    /* Hole */Block.__(6, [y])
                  ]),
                /* :: */[
                  /* tuple */[
                    context,
                    x$1,
                    typ[0],
                    firstExs(exs)
                  ],
                  /* :: */[
                    /* tuple */[
                      context,
                      y,
                      typ[1],
                      sndExs(exs)
                    ],
                    /* [] */0
                  ]
                ]
              ];
    case /* D */3 :
        var adt = typ[0];
        var c = allConstructs(exs);
        if (c === undefined) {
          return Pervasives.failwith("Examples inconsistent with constructor");
        }
        var h$1 = IdGenerator$MyNewProject.getId(undefined);
        var t = Tools$MyNewProject.lookup(c, Tools$MyNewProject.lookup(adt, Types$MyNewProject.sigma));
        return /* tuple */[
                /* Ctor */Block.__(11, [
                    c,
                    adt,
                    /* Hole */Block.__(6, [h$1])
                  ]),
                /* :: */[
                  /* tuple */[
                    context,
                    h$1,
                    t,
                    prepConsExs(exs)
                  ],
                  /* [] */0
                ]
              ];
    default:
      return Pervasives.failwith("Not a refinement type");
  }
}

exports.outFunc = outFunc;
exports.refinable = refinable;
exports.allUnit = allUnit;
exports.allPairs = allPairs;
exports.allFuncs = allFuncs;
exports.allConstructs = allConstructs;
exports.firstExs = firstExs;
exports.sndExs = sndExs;
exports.prepFuncExs = prepFuncExs;
exports.prepConsExs = prepConsExs;
exports.refine = refine;
/* No side effect */
