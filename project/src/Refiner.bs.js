// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Tools$MyNewProject = require("./Tools.bs.js");
var Types$MyNewProject = require("./Types.bs.js");
var Printer$MyNewProject = require("./Printer.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var IdGenerator$MyNewProject = require("./IdGenerator.bs.js");

function refinable(typ, exs) {
  if (typeof typ === "number") {
    if (typ === /* Unit_t */2) {
      return true;
    } else {
      return false;
    }
  }
  switch (typ.tag | 0) {
    case /* Function_t */1 :
    case /* Pair_t */2 :
        return true;
    case /* D */3 :
        if (!exs) {
          return true;
        }
        var match = exs[0][1];
        if (typeof match === "number") {
          return false;
        }
        if (match.tag !== /* Ector */4) {
          return false;
        }
        var xs = exs[1];
        var id = match[0];
        return List.length(List.filter((function (param) {
                            var match = param[1];
                            if (typeof match === "number") {
                              throw [
                                    Caml_builtin_exceptions.match_failure,
                                    /* tuple */[
                                      "Refiner.re",
                                      14,
                                      44
                                    ]
                                  ];
                            }
                            if (match.tag === /* Ector */4) {
                              return id === match[0];
                            }
                            throw [
                                  Caml_builtin_exceptions.match_failure,
                                  /* tuple */[
                                    "Refiner.re",
                                    14,
                                    44
                                  ]
                                ];
                          }))(xs)) === List.length(xs);
    default:
      return false;
  }
}

function allUnit(_exs) {
  while(true) {
    var exs = _exs;
    if (!exs) {
      return true;
    }
    var match = exs[0][1];
    if (typeof match !== "number") {
      return false;
    }
    if (match === 0) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allPairs(_exs) {
  while(true) {
    var exs = _exs;
    console.log("Pair check");
    if (!exs) {
      return true;
    }
    var tmp = exs[0][1];
    if (typeof tmp === "number") {
      return false;
    }
    if (tmp.tag !== /* Epair */2) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allFuncs(_exs) {
  while(true) {
    var exs = _exs;
    console.log("Func check");
    if (!exs) {
      return true;
    }
    var tmp = exs[0][1];
    if (typeof tmp === "number") {
      return false;
    }
    if (tmp.tag !== /* Efunc */3) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allConstructs(exs) {
  console.log("Con check");
  var c;
  if (exs) {
    var match = exs[0][1];
    c = typeof match === "number" || match.tag !== /* Ector */4 ? undefined : match[0];
  } else {
    c = undefined;
  }
  if (c === undefined) {
    return ;
  }
  var haveIdC = List.filter((function (param) {
            var tmp = param[1];
            if (typeof tmp === "number" || tmp.tag !== /* Ector */4) {
              return false;
            } else {
              return true;
            }
          }))(exs);
  if (List.length(haveIdC) === List.length(exs)) {
    return c;
  }
  
}

function firstExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          75,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Epair */2) {
                  return /* tuple */[
                          param[0],
                          match[0]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        75,
                        4
                      ]
                    ];
              }), exs);
}

function sndExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          79,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Epair */2) {
                  return /* tuple */[
                          param[0],
                          match[1]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        79,
                        4
                      ]
                    ];
              }), exs);
}

function prepFuncExs(exs, vid) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          83,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Efunc */3) {
                  return /* tuple */[
                          /* :: */[
                            /* tuple */[
                              vid,
                              Types$MyNewProject.valToRes(match[0])
                            ],
                            param[0]
                          ],
                          match[1]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        83,
                        4
                      ]
                    ];
              }), exs);
}

function prepConsExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          87,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Ector */4) {
                  return /* tuple */[
                          param[0],
                          match[2]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        87,
                        4
                      ]
                    ];
              }), exs);
}

function refine(context, typ, exs) {
  console.log(Printer$MyNewProject.string_of_type_(typ));
  if (typeof typ === "number") {
    if (typ !== /* Unit_t */2) {
      return Pervasives.failwith("Not a refinement type");
    }
    if (allUnit(exs)) {
      return /* tuple */[
              /* Unit */1,
              /* [] */0
            ];
    }
    
  } else {
    switch (typ.tag | 0) {
      case /* Function_t */1 :
          var t1 = typ[0];
          if (allFuncs(exs)) {
            var x = IdGenerator$MyNewProject.getId(undefined);
            var h = IdGenerator$MyNewProject.getId(undefined);
            return /* tuple */[
                    /* Function */Block.__(4, [
                        x,
                        t1,
                        /* Hole */Block.__(6, [h])
                      ]),
                    /* :: */[
                      /* tuple */[
                        /* :: */[
                          /* tuple */[
                            x,
                            t1
                          ],
                          context
                        ],
                        h,
                        typ[1],
                        prepFuncExs(exs, x)
                      ],
                      /* [] */0
                    ]
                  ];
          }
          break;
      case /* Pair_t */2 :
          if (allPairs(exs)) {
            var x$1 = IdGenerator$MyNewProject.getId(undefined);
            var y = IdGenerator$MyNewProject.getId(undefined);
            return /* tuple */[
                    /* Pair */Block.__(8, [
                        /* Hole */Block.__(6, [x$1]),
                        /* Hole */Block.__(6, [y])
                      ]),
                    /* :: */[
                      /* tuple */[
                        context,
                        x$1,
                        typ[0],
                        firstExs(exs)
                      ],
                      /* :: */[
                        /* tuple */[
                          context,
                          y,
                          typ[1],
                          sndExs(exs)
                        ],
                        /* [] */0
                      ]
                    ]
                  ];
          }
          break;
      case /* D */3 :
          var adt = typ[0];
          var c = allConstructs(exs);
          if (c === undefined) {
            return Pervasives.failwith("Examples inconsistent with constructor");
          }
          var h$1 = IdGenerator$MyNewProject.getId(undefined);
          var t = Tools$MyNewProject.lookup(c, Tools$MyNewProject.lookup(adt, Types$MyNewProject.sigma));
          return /* tuple */[
                  /* Ctor */Block.__(11, [
                      c,
                      adt,
                      /* Hole */Block.__(6, [h$1])
                    ]),
                  /* :: */[
                    /* tuple */[
                      context,
                      h$1,
                      t,
                      prepConsExs(exs)
                    ],
                    /* [] */0
                  ]
                ];
      default:
        return Pervasives.failwith("Not a refinement type");
    }
  }
  console.log(Printer$MyNewProject.string_of_type_(typ));
  console.log(Printer$MyNewProject.string_of_excons(exs));
  return Pervasives.failwith("Goal type inconsistent with examples");
}

exports.refinable = refinable;
exports.allUnit = allUnit;
exports.allPairs = allPairs;
exports.allFuncs = allFuncs;
exports.allConstructs = allConstructs;
exports.firstExs = firstExs;
exports.sndExs = sndExs;
exports.prepFuncExs = prepFuncExs;
exports.prepConsExs = prepConsExs;
exports.refine = refine;
/* No side effect */
