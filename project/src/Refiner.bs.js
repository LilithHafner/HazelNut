// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Types$MyNewProject = require("./Types.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var IdGenerator$MyNewProject = require("./IdGenerator.bs.js");

function refinable(typ) {
  if (typeof typ === "number") {
    if (typ === /* Unit_t */2) {
      return true;
    } else {
      return false;
    }
  }
  switch (typ.tag | 0) {
    case /* Function_t */1 :
    case /* Pair_t */2 :
        return true;
    default:
      return false;
  }
}

function allUnit(_exs) {
  while(true) {
    var exs = _exs;
    if (!exs) {
      return true;
    }
    var match = exs[0][1];
    if (typeof match !== "number") {
      return false;
    }
    if (match === 0) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allPairs(_exs) {
  while(true) {
    var exs = _exs;
    if (!exs) {
      return true;
    }
    var tmp = exs[0][1];
    if (typeof tmp === "number") {
      return false;
    }
    if (tmp.tag !== /* Epair */2) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function allFuncs(_exs) {
  while(true) {
    var exs = _exs;
    if (!exs) {
      return true;
    }
    var tmp = exs[0][1];
    if (typeof tmp === "number") {
      return false;
    }
    if (tmp.tag !== /* Efunc */3) {
      return false;
    }
    _exs = exs[1];
    continue ;
  };
}

function firstExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          38,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Epair */2) {
                  return /* tuple */[
                          param[0],
                          match[0]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        38,
                        4
                      ]
                    ];
              }), exs);
}

function sndExs(exs) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          42,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Epair */2) {
                  return /* tuple */[
                          param[0],
                          match[1]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        42,
                        4
                      ]
                    ];
              }), exs);
}

function prepFuncExs(exs, vid) {
  return List.map((function (param) {
                var match = param[1];
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Refiner.re",
                          46,
                          4
                        ]
                      ];
                }
                if (match.tag === /* Efunc */3) {
                  return /* tuple */[
                          /* :: */[
                            /* tuple */[
                              vid,
                              Types$MyNewProject.valToRes(match[0])
                            ],
                            param[0]
                          ],
                          match[1]
                        ];
                }
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Refiner.re",
                        46,
                        4
                      ]
                    ];
              }), exs);
}

function refine(context, typ, exs) {
  if (typeof typ === "number") {
    if (typ === /* Unit_t */2) {
      if (allUnit(exs)) {
        return /* tuple */[
                /* Unit */1,
                /* [] */0
              ];
      } else {
        return Pervasives.failwith("Goal type inconsistent with examples");
      }
    } else {
      return Pervasives.failwith("Not a refinement type");
    }
  }
  switch (typ.tag | 0) {
    case /* Function_t */1 :
        var t1 = typ[0];
        if (!allFuncs(exs)) {
          return Pervasives.failwith("Goal type inconsistent with examples");
        }
        var x = IdGenerator$MyNewProject.getId(undefined);
        var h = IdGenerator$MyNewProject.getId(undefined);
        return /* tuple */[
                /* Function */Block.__(4, [
                    x,
                    t1,
                    /* Hole */Block.__(6, [h])
                  ]),
                /* :: */[
                  /* tuple */[
                    /* :: */[
                      /* tuple */[
                        x,
                        t1
                      ],
                      context
                    ],
                    h,
                    typ[1],
                    prepFuncExs(exs, x)
                  ],
                  /* [] */0
                ]
              ];
    case /* Pair_t */2 :
        if (!allPairs(exs)) {
          return Pervasives.failwith("Goal type inconsistent with examples");
        }
        var x$1 = IdGenerator$MyNewProject.getId(undefined);
        var y = IdGenerator$MyNewProject.getId(undefined);
        return /* tuple */[
                /* Pair */Block.__(8, [
                    /* Hole */Block.__(6, [x$1]),
                    /* Hole */Block.__(6, [y])
                  ]),
                /* :: */[
                  /* tuple */[
                    context,
                    x$1,
                    typ[0],
                    firstExs(exs)
                  ],
                  /* :: */[
                    /* tuple */[
                      context,
                      y,
                      typ[1],
                      sndExs(exs)
                    ],
                    /* [] */0
                  ]
                ]
              ];
    default:
      return Pervasives.failwith("Not a refinement type");
  }
}

exports.refinable = refinable;
exports.allUnit = allUnit;
exports.allPairs = allPairs;
exports.allFuncs = allFuncs;
exports.firstExs = firstExs;
exports.sndExs = sndExs;
exports.prepFuncExs = prepFuncExs;
exports.refine = refine;
/* No side effect */
